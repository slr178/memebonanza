<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meme Bonanza</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎰</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎰</text></svg>">
    <meta name="theme-color" content="#ff3ebf">

    <!-- Google Font: Poppins -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet">

    <!-- GSAP (Particle Animations) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Physics2DPlugin.min.js"></script>

    <!-- Link to updated styles.css -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- Payouts Box Rework -->
    <style>
        /* ─────────────── SLOT HEADER ─────────────── */
        .monitor-header {
            background: linear-gradient(135deg, #ff3ebf, #74b9ff);
            padding: 12px 0;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .monitor-header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 1.6rem;
            color: #ffffff;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
            margin: 0;
        }

        /* ─────────────── PAYOUTS BOX ─────────────── */
        .payouts-box {
            background: rgba(20, 20, 20, 0.85);
            border: 2px solid #ff3ebf;
            border-radius: 10px;
            padding: 16px;
            width: 280px;
            color: #e3e3e5;
            font-family: "Poppins", sans-serif;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
            margin-left: 16px;
        }

        .payouts-box h3 {
            font-size: 1.2rem;
            margin-bottom: 12px;
            text-align: center;
            color: #ff3ebf;
            font-family: 'Press Start 2P', monospace;
        }

        /* Container for all symbol rows */
        .symbols-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 16px;
        }

        /* Each row: icon + name + payout aligned neatly */
        .symbols-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(40, 40, 42, 0.7);
            border: 1px solid rgba(255, 62, 191, 0.3);
            border-radius: 6px;
            padding: 8px 10px;  /* Adjusted padding */
            transition: background 0.2s;
            box-sizing: border-box;  /* Added */
            overflow: hidden;  /* Added */
        }

        .symbols-row:hover {
            background: rgba(255, 62, 191, 0.05);
        }

        /* Icons without borders/shadows */
        .symbols-row .symbol-icon {
            width: 32px;
            height: 32px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            margin-right: 10px;
            flex-shrink: 0;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        /* Symbol name and payout */
        .symbol-name {
            font-size: 0.95rem;
            color: #e3e3e5;
            flex-grow: 1;
            font-family: 'Poppins', sans-serif;
            padding: 0 8px;
        }

        .symbol-payout {
            font-size: 0.95rem;
            color: #74b9ff;
            font-weight: bold;
            flex: 0 0 auto;  /* Added */
            max-width: 60px;  /* Added */
            text-align: right;
            white-space: nowrap;  /* Added */
            overflow: hidden;  /* Added */
            text-overflow: ellipsis;  /* Added */
            margin-left: 8px;  /* Added */
            font-family: 'Press Start 2P', monospace;
        }

        /* Rules section */
        .payouts-rules {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 62, 191, 0.3);
        }

        .payouts-rules p {
            margin: 4px 0;
            font-size: 0.85rem;
            color: #e3e3e5;
            line-height: 1.2;
            font-family: 'Poppins', sans-serif;
        }

        .payouts-rules strong {
            color: #ff3ebf;
        }

        /* Payout colors by rarity */
        .symbols-row:nth-child(4) .symbol-payout,
        .symbols-row:nth-child(5) .symbol-payout {
            color: #ffd700; /* gold */
        }

        .symbols-row:nth-child(6) .symbol-payout,
        .symbols-row:nth-child(7) .symbol-payout {
            color: #ff00ff; /* magenta */
        }

        .symbols-row:nth-child(8) .symbol-payout {
            color: #ff3ebf; /* neon pink */
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .payouts-box {
                width: 260px;
                padding: 14px;
            }
            
            .symbol-name {
                font-size: 0.9rem;
            }
            
            .symbol-payout {
                font-size: 0.8rem;
            }

            .symbols-row .symbol-icon {
                width: 28px;
                height: 28px;
            }
        }

        @media (max-width: 768px) {
            .payouts-box {
                width: 240px;
                margin-left: 8px;
                padding: 12px;
            }
            
            .symbols-row {
                padding: 6px 10px;
            }
            
            .symbols-row .symbol-icon {
                width: 24px;
                height: 24px;
            }

            .symbol-name {
                font-size: 0.8rem;
            }
            
            .symbol-payout {
                font-size: 0.7rem;
                min-width: 50px;
            }
        }

        /* ─────────────────────────────────────────────────────────────────────────────
           Expand the Payouts panel so percentages no longer truncate
        ───────────────────────────────────────────────────────────────────────────── */

        /* 1) Make the right column (containing .payouts-box) wider */
        .right-column {
            flex: 0 0 340px !important; /* was 280px; bump it up to 340px */
        }

        /* 2) Increase the width of .payouts-box itself to match */
        .payouts-box {
            width: 100%; /* when .right-column is 340px, this will fill that space */
            max-width: 340px; /* prevent it from growing wider on large screens */
        }

        /* 3) Give the payout values a bit more room so "100%" etc. don't truncate */
        .payouts-box .symbol-payout {
            max-width: 80px;    /* was 60px; now percentages up to "100%" fit comfortably */
            /* (keep overflow:hidden and text-overflow:ellipsis in case someone adds a longer string) */
        }

        /* 4) (Optional) Reduce horizontal padding on each row so there's more text‐space */
        .payouts-box .symbols-row {
            padding: 8px 8px 8px 12px; /* top/right/bottom/left: 8px 8px 8px 12px */
            /* by reducing the right padding from 10px to 8px, you gain 2px more for text */
        }
    </style>
    
    <!-- Audio Controls & Slot Machine Layering -->
    <style>
        /* Ensure slot container creates a stacking context and stays on top */
        .slot-focus-container {
            position: relative;
            z-index: 10;
        }

        /* Audio controls positioning and layering - now below payouts */
        .bottom-audio-controls {
            position: relative;
            z-index: 5 !important;
            transition: opacity 0.3s ease;
        }

        /* Hide audio controls when slot is focused/zoomed */
        .slot-focus-container.focused .bottom-audio-controls {
            opacity: 0;
            pointer-events: none;
        }

        /* Ensure slot content stays above everything when zoomed */
        .slot-focus-container.focused {
            z-index: 20;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .bottom-audio-controls {
                margin-top: 10px;
            }
        }

        /* ─────────────── ENHANCED AUTO-SPIN SYSTEM ─────────────── */
        .enhanced-autospin-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 229, 255, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .autospin-controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .autospin-label {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #00e5ff;
            text-shadow: 0 0 5px rgba(0, 229, 255, 0.8);
        }

        .autospin-input {
            width: 80px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 229, 255, 0.5);
            border-radius: 6px;
            color: #ffffff;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .autospin-input:focus {
            outline: none;
            border-color: #00e5ff;
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
            background: rgba(0, 0, 0, 0.9);
        }

        .autospin-input:disabled {
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 255, 255, 0.2);
            color: #888;
            cursor: not-allowed;
        }

        .autospin-btn {
            background: linear-gradient(135deg, #00e5ff, #0099cc);
            border: 2px solid #00e5ff;
            color: #000;
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: none;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        }

        .autospin-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #33edff, #00e5ff);
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.5);
            transform: scale(1.05);
        }

        .autospin-btn:disabled {
            background: linear-gradient(135deg, #555, #333);
            border-color: #666;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }

        .stop-autospin-btn {
            background: linear-gradient(135deg, #ff3e3e, #cc1010);
            border: 2px solid #ff6b6b;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255, 62, 62, 0.8);
            box-shadow: 0 0 10px rgba(255, 62, 62, 0.3);
        }

        .stop-autospin-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ff6b6b, #ff3e3e);
            box-shadow: 0 0 15px rgba(255, 62, 62, 0.5);
            transform: scale(1.05);
        }

        .stop-autospin-btn:disabled {
            background: linear-gradient(135deg, #555, #333);
            border-color: #666;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
            text-shadow: none;
        }

        /* Progress Wrapper */
        .autospin-progress-wrapper {
            width: 100%;
            max-width: 300px;
            display: none;
            margin-top: 8px;
        }

        .autospin-progress-wrapper.active {
            display: block;
        }

        /* Progress Bar */
        .autospin-progress-bar {
            width: 0%;
            height: 10px;
            background: linear-gradient(90deg, #00e5ff, #ff3ebf);
            transition: width 0.4s ease;
            border-radius: 6px;
            box-shadow: 
                0 0 10px rgba(0, 229, 255, 0.5),
                inset 0 0 5px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .autospin-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progressShimmer 2s infinite;
        }

        @keyframes progressShimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Status Text */
        .autospin-status {
            margin-top: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            color: #00e5ff;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 229, 255, 0.8);
        }

        /* ─────────────── TILE REVEAL ANIMATION SYSTEM ─────────────── */
        
        /* Base tile styling - ensure icons can be animated */
        .icon {
            transition: none; /* We handle animations with keyframes */
            position: relative;
            display: block;
        }

        /* When .tile-hidden is applied, push icon way above the viewport */
        .icon.tile-hidden {
            opacity: 0;
            transform: translateY(-100vh);
            transition: none;
        }

        /* Define the "drop-in" keyframes - drop from above entire screen */
        @keyframes tileDropIn {
            0% {
                opacity: 0;
                transform: translateY(-100vh);
            }
            70% {
                opacity: 1;
                transform: translateY(8%);   /* slight overshoot below */
            }
            100% {
                opacity: 1;
                transform: translateY(0);     /* settle exactly in place */
            }
        }

        /* When .tile-reveal is added, play the drop-in animation */
        .icon.tile-reveal {
            animation: tileDropIn 0.5s ease-out forwards;
            /* "forwards" ensures it stays at translateY(0)/opacity:1 at the end */
        }

        /* Optional: Staggered reveal animation for more dynamic effect */
        .icon.tile-reveal.delay-1 { animation-delay: 0.05s; }
        .icon.tile-reveal.delay-2 { animation-delay: 0.1s; }
        .icon.tile-reveal.delay-3 { animation-delay: 0.15s; }
        .icon.tile-reveal.delay-4 { animation-delay: 0.2s; }

        /* ────────────────────────────────────────────────────────────────────────────
           EXPLODE ANIMATION - For vertical column matches
        ──────────────────────────────────────────────────────────────────────────── */
        
        /* Explode keyframes: scale up + fade out */
        @keyframes tileExplode {
            0% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.3) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.1) rotate(360deg);
            }
        }

        /* When .tile-explode is added, play the explode animation */
        .icon.tile-explode {
            animation: tileExplode 0.3s ease-in forwards;
            z-index: 100;
        }

        /* Fallback CSS animation for browsers without GSAP */
        @keyframes particleFallback {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(50px, 100px) scale(0); opacity: 0; }
        }

        @keyframes shockwaveFallback {
            0% { transform: scale(0.1); opacity: 0.6; }
            100% { transform: scale(1.3); opacity: 0; }
        }

        /* Enhanced scale animation (kept for compatibility) */
        @keyframes slotResetScale {
            0%   { transform: scale(1); }
            50%  { transform: scale(0.92); }
            100% { transform: scale(1); }
        }

        .slot-area.reset-scale {
            animation: slotResetScale 0.4s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .enhanced-autospin-controls {
                padding: 12px;
                gap: 10px;
            }

            .autospin-input {
                width: 70px;
                padding: 6px 8px;
                font-size: 9px;
            }

            .autospin-btn, .stop-autospin-btn {
                font-size: 8px;
                padding: 6px 12px;
            }

            .autospin-label, .autospin-status {
                font-size: 8px;
            }

            .autospin-progress-bar {
                height: 8px;
            }
        }

        @media (max-width: 480px) {
            .autospin-controls-row {
                flex-direction: column;
                gap: 8px;
            }

            .autospin-progress-wrapper {
                max-width: 250px;
            }
        }

        /* ─────────────── LEFT PANELS CONTAINER ─────────────── */
        .left-panels {
            position: fixed;
            top: 80px;
            left: 16px;
            display: flex;
            flex-direction: row;
            gap: 16px;
            z-index: 100;
        }

        .left-panel {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff3ebf;
            border-radius: 10px;
            padding: 16px;
            color: #e3e3e5;
            width: 200px;
            font-family: "Poppins", sans-serif;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
        }

        .left-panel h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #ff3ebf;
            font-family: 'Press Start 2P', monospace;
            text-align: center;
            margin-bottom: 12px;
        }

        /* ─────────────── PAYOUT REQUEST PANEL ─────────────── */
#payout-panel {
    /* Push it down so it sits below the live-wins panel */
    margin-top: 1000px;
}

#payout-panel form {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

        #payout-amount {
            padding: 10px;
            background: rgba(40, 40, 42, 0.7);
            border: 1px solid rgba(255, 62, 191, 0.3);
            border-radius: 6px;
            color: #e3e3e5;
            font-family: "Poppins", sans-serif;
            font-size: 14px;
        }

        #payout-amount:focus {
            outline: none;
            border-color: #ff3ebf;
            box-shadow: 0 0 8px rgba(255, 62, 191, 0.3);
        }

        #payout-form button {
            background: linear-gradient(135deg, #ff3ebf, #74b9ff);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #payout-form button:hover {
            background: linear-gradient(135deg, #ff6bdf, #94c9ff);
            transform: scale(1.05);
            box-shadow: 0 0 12px rgba(255, 62, 191, 0.4);
        }

        #payout-status {
            margin: 8px 0 0 0;
            font-size: 12px;
            text-align: center;
            min-height: 20px;
        }

        #payout-status.success {
            color: #4CAF50;
        }

        #payout-status.error {
            color: #f44336;
        }

        #payout-status.pending {
            color: #ff9800;
        }

        /* Responsive adjustments for left panels */
        @media (max-width: 1200px) {
            .left-panels {
                flex-direction: column;
                gap: 12px;
            }
            
            .left-panel {
                width: 180px;
            }
        }

        @media (max-width: 768px) {
            .left-panels {
                top: 60px;
                left: 8px;
            }
            
            .left-panel {
                width: 160px;
                padding: 12px;
            }
            
            .left-panel h3 {
                font-size: 9px;
            }
        }
    </style>

    <!-- Token Balance Styles -->
    <style>
        .token-balance {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #FFD700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
            margin: 2px 0;
            padding: 2px 0;
        }
        
        #token-balance {
            color: #00FF00;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
            font-weight: bold;
        }
        
        .wallet-info {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(255, 215, 0, 0.1));
            border: 1px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            padding: 8px 12px;
            margin-left: 10px;
        }
        
        .wallet-address {
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: #00e5ff;
            margin-bottom: 4px;
        }
        
        .spin-count {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #ff3ebf;
            text-shadow: 0 0 5px rgba(255, 62, 191, 0.8);
        }
        
        #available-spins {
            color: #00FF00;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
            font-weight: bold;
        }
    </style>
    

    <!-- Bootstrap 4 / jQuery (for the count-up animation) -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
    <!-- Particles Container for Explosion Effects -->
    <div id="particles-container"></div>

    <!-- Video Background -->
    <video id="background-video" autoplay muted loop playsinline>
        <source src="backgroundnew.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <!-- Curtain Intro Screen -->
    <div class="landing-screen" id="landing-screen">
        <div class="content">
            <!-- Clean background - no content behind curtains -->
        </div>
        <div class="curtainBody">
            <div id="leftCurtain" class="curtainContainer">
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
            </div>
            <div id="rightCurtain" class="curtainContainer">
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
                <div class="unCurtain"></div>
            </div>
            <div class="overlay">
                <a href="#" id="enter-casino-btn" class="neon-button">
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                    Enter Meme Casino
                </a>
            </div>
        </div>
    </div>

    <!-- Main Casino Content (Initially Hidden) -->
    <div class="casino-content" id="casino-content" style="display: none;">
        <!-- Left Panels Container -->
        <div class="left-panels">
            <!-- New Payout Request Panel -->
            <div id="payout-panel" class="left-panel">
                <h3>Payout Request</h3>
                <form id="payout-form">
                    <input type="number" id="payout-amount" step="0.001" placeholder="Amount (SOL)" />
                    <button type="submit">Request</button>
                </form>
                <p id="payout-status"></p>
            </div>
            
            <!-- Existing Payout Info Display -->
            <div class="permanent-info left-panel">
                <h3>🎰 Payout Info</h3>
                <div class="symbol-list">
                    <div class="symbol-info">
                        <div class="symbol-icon s-symbol"></div>
                        <span class="symbol-name">S (Common)</span>
                        <span class="symbol-payout">0.001%</span>
                    </div>
                    <div class="symbol-info">
                        <div class="symbol-icon o-symbol"></div>
                        <span class="symbol-name">O (Common)</span>
                        <span class="symbol-payout">0.002%</span>
                    </div>
                    <div class="symbol-info">
                        <div class="symbol-icon l-symbol"></div>
                        <span class="symbol-name">L (Common)</span>
                        <span class="symbol-payout">0.005%</span>
                    </div>
                    <div class="symbol-info">
                        <div class="symbol-icon trump-symbol"></div>
                        <span class="symbol-name">Trump/Elon</span>
                        <span class="symbol-payout">0.5%</span>
                    </div>
                    <div class="symbol-info">
                        <div class="symbol-icon dog-symbol"></div>
                        <span class="symbol-name">Dog/Cat</span>
                        <span class="symbol-payout">1%</span>
                    </div>
                    <div class="symbol-info">
                        <div class="symbol-icon pepe-symbol"></div>
                        <span class="symbol-name">Pepe</span>
                        <span class="symbol-payout">100%</span>
                    </div>
                </div>
                <div class="rules-section">
                    <p><strong>Win:</strong> 3+ consecutive columns</p>
                    <p><strong>Multiplier:</strong> Total symbols ÷ 3</p>
                    <p><strong>Cascades:</strong> 1 + (cascades-1) × 0.5</p>
                    <p><strong>Win Rate:</strong> ~6.35%</p>
                </div>
            </div>
        </div>

        <!-- Audio Elements -->
        <audio id="background-music" loop>
            <source src="backgroundmusicnew.mp3" type="audio/mpeg">
            <source src="backgroundmusicnew.wav" type="audio/wav">
        </audio>
        
        <audio id="spin-buildup-music">
            <source src="buildup.mp3" type="audio/mpeg">
            <source src="buildup.wav" type="audio/wav">
        </audio>

        <audio id="tumble-sound">
            <source src="incomingtumble.mp3" type="audio/mpeg">
            <source src="incomingtumble.wav" type="audio/wav">
        </audio>

        <!-- Audio for countdown -->
        <audio id="countdown-sound">
            <source src="countdown.mp3" type="audio/mpeg">
            <source src="countdown.wav" type="audio/wav">
        </audio>

        <!-- Audio for auto-spin -->
        <audio id="auto-spin-music" loop>
            <source src="autospinmusic.mp3" type="audio/mpeg">
            <source src="autospinmusic.wav" type="audio/wav">
        </audio>





        <!-- ─── TOP BAR: Prize Pool + Connect Wallet ─── -->
<div class="top-prize-wallet-bar">
  <!-- Prize Pool -->
    <div class="pool-display">
        <div class="pool-title">💰 PRIZE POOL 💰</div>
        <div class="pool-amounts">
            <span class="pool-sol"><span id="top-pool-amount">300</span> SOL</span>
            <span class="pool-divider">≈</span>
            <span class="pool-usd">$<span id="top-pool-usd">45,000</span></span>
        </div>
    </div>
  <!-- Connect Wallet -->
    <div class="wallet-section">
        <button id="connect-wallet-btn" class="wallet-btn">
            <span class="wallet-icon">👤</span>
            <span class="wallet-text">Connect Wallet</span>
        </button>
        <div id="wallet-info" class="wallet-info" style="display: none;">
            <div class="wallet-address" id="wallet-address"></div>
      <!-- Show balances -->
      <div class="token-balance">
        <span class="label">SOL Balance:</span>
        <span id="sol-balance">0.000000</span>
      </div>
      <div class="token-balance">
        <span class="label">Token Balance:</span>
        <span id="token-balance">0</span>
      </div>
      <!-- Show how many spins remain -->
      <div class="spin-count">
        <span class="label">Spins:</span>
        <span id="available-spins">0</span>
      </div>
      <!-- Show total earnings -->
      <div class="total-earnings">
        <span class="label">Total Earned:</span>
        <span id="total-earnings">0</span> SOL
      </div>
      <!-- Show refresh timer -->
      <div class="refresh-timer">
        <span class="label">Next Refresh:</span>
        <span id="refresh-timer">--</span>
      </div>
      <!-- Disconnect wallet button -->
      <button id="disconnect-wallet-btn" class="disconnect-wallet-btn">
        <span class="wallet-icon">🚪</span>
        <span class="wallet-text">Disconnect</span>
      </button>
    </div>
  </div>
</div>

        <!-- ─── SLOT FOCUS CONTAINER ─── -->
        <div class="slot-focus-container">
            <!-- ─── "ARCADE MONITOR" CONTAINER ─── -->
            <div class="arcade-monitor">
            <!-- Top title bar -->
            <div class="monitor-header">
                <h1>MEME BONANZA</h1>
            </div>

            <!-- ─── MAIN CONTENT: reels + payouts ─── -->
            <div class="monitor-content">


                <!-- ═══ LIVE CRYPTO WINS - REDESIGNED ═══ -->
                <div class="live-wins-panel">
                    <div class="panel-header">
                        <div class="header-icon">💎</div>
                        <div class="header-content">
                            <h2 class="panel-title">Live Wins</h2>
                            <div class="win-counter">
                                <span class="counter-label">Total Wins:</span>
                                <span class="counter-value" id="total-wins-counter">24,891</span>
                            </div>
                        </div>
                        <div class="panel-pulse"></div>
                    </div>
                    
                    <div class="wins-stream" id="wins-stream">
                        <!-- Dynamic win entries will be inserted here -->
                        <div class="win-entry demo-win">
                            <div class="win-main-row">
                                <div class="win-avatar">
                                    <div class="avatar-ring"></div>
                                    <div class="avatar-icon">🎯</div>
                                </div>
                                <div class="win-details">
                                    <div class="win-player">Anonymous Player</div>
                                    <div class="win-amount">
                                        <span class="sol-amount">+0.458 SOL</span>
                                        <span class="usd-amount">≈ $68.70</span>
                                    </div>
                                    <div class="win-type">Triple Match • Cascade x3</div>
                                </div>
                                <div class="win-glow"></div>
                            </div>
                            <div class="expand-indicator">▼</div>
                            <div class="win-expanded-details">
                                <div class="expanded-row">
                                    <span class="expanded-label">Full Address:</span>
                                    <span class="expanded-value expanded-wallet">7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Timestamp:</span>
                                    <span class="expanded-value expanded-timestamp">Now</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Win Symbols:</span>
                                    <span class="expanded-value">⚡ ⚡ ⚡</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Multiplier:</span>
                                    <span class="expanded-value">3x</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="win-entry demo-win">
                            <div class="win-main-row">
                                <div class="win-avatar">
                                    <div class="avatar-ring"></div>
                                    <div class="avatar-icon">⚡</div>
                                </div>
                                <div class="win-details">
                                    <div class="win-player">Lucky Spinner</div>
                                    <div class="win-amount">
                                        <span class="sol-amount">+1.234 SOL</span>
                                        <span class="usd-amount">≈ $185.10</span>
                                    </div>
                                    <div class="win-type">Rare Symbol • Big Win!</div>
                                </div>
                                <div class="win-glow"></div>
                            </div>
                            <div class="expand-indicator">▼</div>
                            <div class="win-expanded-details">
                                <div class="expanded-row">
                                    <span class="expanded-label">Full Address:</span>
                                    <span class="expanded-value expanded-wallet">9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Timestamp:</span>
                                    <span class="expanded-value expanded-timestamp">2 min ago</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Win Symbols:</span>
                                    <span class="expanded-value">💎 💎 💎 💎</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Multiplier:</span>
                                    <span class="expanded-value">4x</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="win-entry demo-win mega">
                            <div class="win-main-row">
                                <div class="win-avatar">
                                    <div class="avatar-ring"></div>
                                    <div class="avatar-icon">🔥</div>
                                </div>
                                <div class="win-details">
                                    <div class="win-player">Mega Winner</div>
                                    <div class="win-amount">
                                        <span class="sol-amount">+5.789 SOL</span>
                                        <span class="usd-amount">≈ $868.35</span>
                                    </div>
                                    <div class="win-type">JACKPOT • Legendary!</div>
                                </div>
                                <div class="win-glow"></div>
                            </div>
                            <div class="expand-indicator">▼</div>
                            <div class="win-expanded-details">
                                <div class="expanded-row">
                                    <span class="expanded-label">Full Address:</span>
                                    <span class="expanded-value expanded-wallet">ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Timestamp:</span>
                                    <span class="expanded-value expanded-timestamp">5 min ago</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Win Symbols:</span>
                                    <span class="expanded-value">🔥 🔥 🔥 🔥 🔥</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Multiplier:</span>
                                    <span class="expanded-value">5x</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel-footer">
                        <div class="live-indicator">
                            <div class="live-dot"></div>
                            <span>Live Updates</span>
                        </div>
                        <div class="panel-stats">
                            <span class="stat-item">
                                <span class="stat-value">🎰</span>
                                <span class="stat-label">24/7</span>
                            </span>
                        </div>
                    </div>
                </div>

                <!-- CENTER: slot machine + result -->
                <div class="slot-area">
                    <div class="reel-wrapper">
            <!-- Countdown element (starts hidden) -->
            <div class="countdown"></div>
                        
                        <!-- Five columns -->
                        <div class="reel">
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                        </div>
                        <div class="reel">
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                        </div>
                        <div class="reel">
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                        </div>
                        <div class="reel">
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                        </div>
                        <div class="reel">
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                            <div class="icons-group">
                                <div class="icon figure-1"></div>
                                <div class="icon figure-2"></div>
                                <div class="icon figure-3"></div>
                                <div class="icon figure-4"></div>
                                <div class="icon figure-5"></div>
                                <div class="icon figure-6"></div>
                                <div class="icon figure-7"></div>
                                <div class="icon figure-8"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Result display + SPIN button -->
                    <div class="game-info">
                        <div class="win-counters">
                            <div class="count-up">
                                <p id="counter-sol" class="counter-count">0</p>
                                <h3>You won (SOL)</h3>
                            </div>
                            <div class="count-up">
                                <p id="counter-usd" class="counter-count">0</p>
                                <h3>Equivalent (USD)</h3>
                            </div>
                        </div>

                        <div class="result-display" id="result"></div>
                        
                        <!-- Single SPIN button moved inside game-info -->
                        <input id="btn-spin" class="hidden-toggle" type="checkbox" />
                        <label for="btn-spin" class="spin-btn">SPIN</label>
                    </div>

                    <!-- Enhanced Auto-Spin Controls -->
                    <div class="spin-container">
                        <div id="autoSpinContainer" class="enhanced-autospin-controls">
                            <div class="autospin-controls-row">
                                <label for="autoSpinInput" class="autospin-label">Auto-Spin:</label>
                                <input
                                    type="number"
                                    id="autoSpinInput"
                                    class="autospin-input"
                                    min="1"
                                    max="999"
                                    value="10"
                                    title="Number of automatic spins"
                                />
                                <button id="autoSpinBtn" class="autospin-btn" title="Start Auto-Spin sequence">
                                    START AUTO-SPIN
                                </button>
                                <button id="stopAutoSpinBtn" class="stop-autospin-btn" disabled title="Stop Auto-Spin immediately">
                                    STOP
                                </button>
                            </div>

                            <!-- Progress & Status Display -->
                            <div id="autoSpinProgressWrapper" class="autospin-progress-wrapper">
                                <div id="autoSpinProgressBar" class="autospin-progress-bar"></div>
                                <div id="autoSpinStatus" class="autospin-status">
                                    Spins run: 0 / 0
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT SIDE: payouts box -->
                <div class="right-column">
                    <div class="payouts-box">
                        <h3>Payouts</h3>
                        <div class="symbols-list">
                            <!-- Common S -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-1"></div>
                                <span class="symbol-name">S (Common)</span>
                                <span class="symbol-payout">0.001%</span>
                            </div>

                            <!-- Common O -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-2"></div>
                                <span class="symbol-name">O (Common)</span>
                                <span class="symbol-payout">0.002%</span>
                            </div>

                            <!-- Common L -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-3"></div>
                                <span class="symbol-name">L (Common)</span>
                                <span class="symbol-payout">0.005%</span>
                            </div>

                            <!-- Trump (Rare) -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-4"></div>
                                <span class="symbol-name">Trump (Rare)</span>
                                <span class="symbol-payout">0.5%</span>
                            </div>

                            <!-- Elon (Rare) -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-5"></div>
                                <span class="symbol-name">Elon (Rare)</span>
                                <span class="symbol-payout">0.5%</span>
                            </div>

                            <!-- Dog (Epic) -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-6"></div>
                                <span class="symbol-name">Dog (Epic)</span>
                                <span class="symbol-payout">1%</span>
                            </div>

                            <!-- Cat (Epic) -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-7"></div>
                                <span class="symbol-name">Cat (Epic)</span>
                                <span class="symbol-payout">1%</span>
                            </div>

                            <!-- Pepe (Jackpot) -->
                            <div class="symbols-row">
                                <div class="symbol-icon figure-8"></div>
                                <span class="symbol-name">Pepe (Jackpot)</span>
                                <span class="symbol-payout">100%</span>
                            </div>
                        </div>

                        <div class="payouts-rules">
                            <p><strong>Win:</strong> 3+ consecutive columns</p>
                            <p><strong>Rate:</strong> ~6.35%</p>
                        </div>
                    </div>

                    <!-- ─── AUDIO CONTROLS BELOW PAYOUTS ─── -->
                    <div class="bottom-audio-controls">
                        <!-- Music Controls -->
                        <div class="audio-control-item">
                            <button id="music-mute-btn" class="audio-btn music-btn" title="Toggle Music">
                                <span class="audio-icon">🎵</span>
                            </button>
                            <input type="range" id="music-volume-slider" class="volume-slider" 
                                   min="0" max="100" value="30" title="Music Volume">
                            <span class="volume-label">Music</span>
                        </div>
                        
                        <!-- Sound Effects Controls -->
                        <div class="audio-control-item">
                            <button id="sound-mute-btn" class="audio-btn sound-btn" title="Toggle Sound Effects">
                                <span class="audio-icon">🔊</span>
                            </button>
                            <input type="range" id="sound-volume-slider" class="volume-slider" 
                                   min="0" max="100" value="50" title="Sound Effects Volume">
                            <span class="volume-label">SFX</span>
                        </div>
                    </div>
                </div>


            </div><!-- /.monitor-content -->
        </div><!-- /.arcade-monitor -->
        </div><!-- /.slot-focus-container -->

        <!-- ─── NAVIGATION MENU ─── -->
        <nav class="main-navigation">
            <div class="nav-container">
                <a href="index.html" class="nav-link active">🎰 Play</a>
                <a href="how-it-works.html" class="nav-link">📖 How It Works</a>
                <a href="faq.html" class="nav-link">❓ FAQ</a>
                <a href="results.html" class="nav-link">📊 Results</a>
            </div>
        </nav>
    </div>

    <!-- Info Modal -->
    <div class="info-modal" id="info-modal">
        <div class="info-content">
            <div class="info-header">
                <h2>🎰 Payout Information</h2>
                <span class="close-button" id="close-info">&times;</span>
            </div>
            <div class="info-body">
                <div class="payout-section">
                    <h3>Base Payout Percentages:</h3>
                    <div class="symbol-list">
                        <div class="symbol-info">
                            <div class="symbol-icon s-symbol"></div>
                            <span class="symbol-name">S (Common)</span>
                            <span class="symbol-payout">0.001%</span>
                        </div>
                        <div class="symbol-info">
                            <div class="symbol-icon o-symbol"></div>
                            <span class="symbol-name">O (Common)</span>
                            <span class="symbol-payout">0.002%</span>
                        </div>
                        <div class="symbol-info">
                            <div class="symbol-icon l-symbol"></div>
                            <span class="symbol-name">L (Common)</span>
                            <span class="symbol-payout">0.005%</span>
                        </div>
                        <div class="symbol-info">
                            <div class="symbol-icon trump-symbol"></div>
                            <span class="symbol-name">Trump/Elon (Ultra Rare)</span>
                            <span class="symbol-payout">0.5%</span>
                        </div>
                        <div class="symbol-info">
                            <div class="symbol-icon dog-symbol"></div>
                            <span class="symbol-name">Popcat/Dog (Legendary)</span>
                            <span class="symbol-payout">1%</span>
                        </div>
                        <div class="symbol-info">
                            <div class="symbol-icon pepe-symbol"></div>
                            <span class="symbol-name">Pepe (Jackpot!)</span>
                            <span class="symbol-payout">100%</span>
                        </div>
                    </div>
                </div>
                
                <div class="multiplier-section">
                    <h3>How Payouts Work:</h3>
                    <div class="explanation">
                        <p><strong>Win Requirement:</strong> 3+ consecutive columns with same symbol</p>
                        <p><strong>Symbol Multiplier:</strong> Total symbols ÷ 3</p>
                        <p><strong>Cascade Multiplier:</strong> 1 + (cascades-1) × 0.5</p>
                        <p><strong>Final Payout:</strong> Base% × Symbol Multiplier × Cascade Multiplier</p>
                    </div>
                </div>
                
                <div class="odds-section">
                    <h3>Win Statistics:</h3>
                    <div class="stats">
                        <p><strong>Overall Win Rate:</strong> ~6.35%</p>
                        <p><strong>Trump/Elon Win Rate:</strong> ~0.01% (ultra rare!)</p>
                        <p><strong>Popcat/Dog Win Rate:</strong> ~0.005% (legendary rare!)</p>
                        <p><strong>Pepe Jackpot Rate:</strong> ~0.001% (mythical!)</p>
                        <p><strong>Maximum Possible Payout:</strong> ~5,500% with mega cascades!</p>
                        <p><strong>Typical Win:</strong> 0.001% - 0.005% (base symbols only)</p>
                        <p><strong>Expected Value:</strong> Extremely house-favored</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Win Result Popup -->
    <div class="win-popup" id="win-popup">
        <div class="win-popup-overlay"></div>
        <div class="win-popup-content">
            <div class="win-popup-header">
                <div class="win-popup-title" id="win-popup-title">🎰 WIN!</div>
                <div class="win-popup-close" id="win-popup-close">&times;</div>
            </div>
            <div class="win-popup-body">
                <div class="win-details" id="win-details">
                    <div class="win-symbols" id="win-symbols"></div>
                    <div class="win-explanation" id="win-explanation"></div>
                    <div class="win-payout" id="win-payout"></div>
                </div>
                <div class="win-breakdown" id="win-breakdown"></div>
                <div class="win-social-actions">
                    <button class="tweet-win-btn" id="tweet-win-btn" onclick="tweetWin()">
                        🐦 Tweet Your Win!
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ───────────────────────────────────────────────────────────────────────────
    // 1. Define the "symbol groups" and their weights
    // ───────────────────────────────────────────────────────────────────────────

    // Initialize GSAP plugins
    document.addEventListener('DOMContentLoaded', function() {
        // Register GSAP plugins
        if (typeof gsap !== 'undefined' && gsap.registerPlugin) {
            try {
                gsap.registerPlugin(Physics2DPlugin);
                console.log('✓ GSAP Physics2D plugin registered successfully');
            } catch (e) {
                console.warn('Physics2D plugin registration failed:', e);
            }
        }
    });

    const outcomes = [
        { name: "S-triple",   symbols: ["figure-1"],       weight: 3, payoutPercent: 0.001 },   // 0.001% of pool
        { name: "O-triple",   symbols: ["figure-2"],       weight: 2, payoutPercent: 0.002 },   // 0.002% of pool
        { name: "L-triple",   symbols: ["figure-3"],       weight: 1, payoutPercent: 0.005 },   // 0.005% of pool
        { name: "Trump/Elon", symbols: ["figure-4","figure-5"], weight: 0.01, payoutPercent: 0.5 },  // 0.5% of pool (50 coins) - ULTRA RARE
        { name: "Popcat/Dog", symbols: ["figure-7","figure-6"], weight: 0.005, payoutPercent: 1 }, // 1% of pool (100 coins) - LEGENDARY RARE
        { name: "PEPE JACKPOT", symbols: ["figure-8"], weight: 0.001, payoutPercent: 100 }, // 100% of pool - ULTRA RARE!
    ];

    // Build weighted "wheel" array (1000-sized) where null = no-win
    const wheel = [];
    outcomes.forEach(o => {
        for (let i = 0; i < o.weight * 10; i++) wheel.push(o);
    });
    const totalWeight = outcomes.reduce((sum,o) => sum + o.weight * 10, 0);
    const noWinCount = 1000 - totalWeight;
    for (let i = 0; i < noWinCount; i++) {
        wheel.push(null);
    }

    function randIndex(n) {
        return Math.floor(Math.random() * n);
    }

    const winSound = new Audio('win.mp3');
    winSound.volume = 0.5;

    // Explosion sound for dramatic effects
    const explosionSound = new Audio('win.mp3'); // Using win sound as explosion for now
    explosionSound.volume = 0.3;

    // Particles container reference
    const particlesContainer = document.getElementById('particles-container');

    // MEGA EXPLOSION FUNCTIONS FOR SLOT CASCADES - OPTIMIZED
    function createSlotExplosion(x, y, intensity = 1) {
        // Check if GSAP is available
        if (typeof gsap === 'undefined') {
            console.warn('GSAP not available, skipping explosion effect');
            return;
        }

        // Reduced particle count for better performance
        const baseTotalParticles = 30 * intensity; // Reduced from 60
        const totalParticles = Math.floor(baseTotalParticles);
        
        // Slot machine themed colors
        const colors = [
            "#FFD700", // Gold
            "#FF6B6B", // Coral Red  
            "#87CEEB", // Sky Blue
            "#98FB98", // Pale Green
            "#DDA0DD", // Plum
            "#F0E68C", // Khaki
            "#FFA500", // Orange
            "#FF69B4"  // Hot Pink
        ];

        // Play explosion sound with slight delay for layering
        explosionSound.currentTime = 0;
        ensureAudioMuteState(explosionSound, false);
        explosionSound.play().catch(e => console.log("Explosion audio failed:", e));

        // Reduced wave count for performance
        const numWaves = 2; // Reduced from 3
        for (let wave = 0; wave < numWaves; wave++) {
            setTimeout(() => {
                const waveParticles = Math.floor(totalParticles / numWaves);
                for (let i = 0; i < waveParticles; i++) {
                    const particle = document.createElement("div");
                    particle.className = "particle";
                    
                    // Reduced special particle types for performance
                    if (Math.random() > 0.8) particle.classList.add('circular');
                    
                    const size = Math.random() * 12 + 4; // Smaller particles
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    Object.assign(particle.style, {
                        position: "fixed",
                        backgroundColor: color,
                        width: size + "px",
                        height: size + "px",
                        borderRadius: Math.random() > 0.5 ? "2px" : "50%",
                        pointerEvents: "none",
                        zIndex: "10000",
                        boxShadow: `0 0 ${Math.random() * 3 + 1}px ${color}66`, // Reduced glow
                        willChange: "transform, opacity" // Performance optimization
                    });
                    
                    particlesContainer.appendChild(particle);
                    
                    try {
                        gsap.set(particle, { 
                            x, 
                            y, 
                            scale: Math.random() * 1.2 + 0.4, // Smaller scale range
                            rotation: Math.random() * 360
                        });
                        
                        gsap.to(particle, {
                            duration: 1.2 + Math.random() * 0.6, // Shorter duration
                            physics2D: {
                                velocity: (Math.random() * 200 + 80 + wave * 30) * intensity, // Reduced velocity
                                angle: Math.random() * 360,
                                gravity: 100 + wave * 15, // Reduced gravity
                                friction: 0.04,
                                angularVelocity: Math.random() * 300 - 150 // Reduced rotation
                            },
                            opacity: 0,
                            scale: 0.1,
                            ease: "power2.out",
                            onComplete: () => {
                                if (particlesContainer.contains(particle)) {
                                    particlesContainer.removeChild(particle);
                                }
                            }
                        });
                    } catch (e) {
                        // Fallback animation with CSS if GSAP fails
                        console.warn('GSAP animation failed, using CSS fallback');
                        particle.style.left = x + 'px';
                        particle.style.top = y + 'px';
                        particle.style.animation = 'particleFallback 1.5s ease-out forwards';
                        setTimeout(() => {
                            if (particlesContainer.contains(particle)) {
                                particlesContainer.removeChild(particle);
                            }
                        }, 1500);
                    }
                }

                // Create fewer shockwave rings
                if (wave === 0) { // Only first wave gets shockwave
                    const shockParticle = document.createElement("div");
                    const shockSize = 30 + wave * 20; // Smaller shockwaves
                    Object.assign(shockParticle.style, {
                        position: "fixed",
                        width: `${shockSize}px`,
                        height: `${shockSize}px`,
                        borderRadius: "50%",
                        border: `2px solid rgba(255, 215, 0, ${0.5 - wave * 0.1})`, // Reduced opacity
                        opacity: 0.6 - wave * 0.1,
                        zIndex: 9999,
                        pointerEvents: "none",
                        willChange: "transform, opacity"
                    });
                    
                    particlesContainer.appendChild(shockParticle);
                    
                    try {
                        gsap.set(shockParticle, {
                            x: x - shockSize / 2,
                            y: y - shockSize / 2,
                            scale: 0.1
                        });
                        
                        gsap.to(shockParticle, {
                            duration: 0.4 + wave * 0.1, // Faster animation
                            scale: 1.3 + wave * 0.1, // Smaller scale
                            opacity: 0,
                            ease: "expo.out",
                            onComplete: () => {
                                if (particlesContainer.contains(shockParticle)) {
                                    particlesContainer.removeChild(shockParticle);
                                }
                            }
                        });
                    } catch (e) {
                        // Fallback for shockwave
                        shockParticle.style.left = (x - shockSize / 2) + 'px';
                        shockParticle.style.top = (y - shockSize / 2) + 'px';
                        shockParticle.style.animation = 'shockwaveFallback 0.4s ease-out forwards';
                        setTimeout(() => {
                            if (particlesContainer.contains(shockParticle)) {
                                particlesContainer.removeChild(shockParticle);
                            }
                        }, 400);
                    }
                }
            }, wave * 40); // Faster wave timing
        }
    }

    // Function to trigger explosion at symbol position
    function createSymbolExplosion(symbolElement) {
        const rect = symbolElement.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        createSlotExplosion(centerX, centerY, 0.8);
    }

    // Mega explosion for big wins - OPTIMIZED
    function createMegaWinExplosion() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        // Reduced number of explosions for performance
        createSlotExplosion(centerX, centerY, 1.2); // Reduced intensity
        setTimeout(() => createSlotExplosion(centerX - 80, centerY - 40, 0.8), 150); // Reduced timing and intensity
        setTimeout(() => createSlotExplosion(centerX + 80, centerY + 40, 0.8), 300);
    }

    // Audio elements
    const backgroundMusic = document.getElementById('background-music');
    const spinBuildupMusic = document.getElementById('spin-buildup-music');
    const tumbleSound = document.getElementById('tumble-sound');
    const countdownSound = document.getElementById('countdown-sound');
    
    // Set audio volumes
    backgroundMusic.volume = 0.3; // Lower volume for background
    spinBuildupMusic.volume = 0.6; // Higher volume for spin buildup
    tumbleSound.volume = 0.4; // Medium volume for tumbles
    countdownSound.volume = 0.5; // Medium volume for countdown
    
    // Initialize background music
    function initializeBackgroundMusic() {
        ensureAudioMuteState(backgroundMusic, true);
        const playPromise = backgroundMusic.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('🎵 Background music playing');
            }).catch(() => {
                console.warn('Background music autoplay failed - user interaction required');
                // Try to start music on first user interaction
                document.addEventListener('click', () => {
                    ensureAudioMuteState(backgroundMusic, true);
                    backgroundMusic.play().catch(e => console.warn('Background music play error:', e));
                }, { once: true });
            });
        }
        backgroundMusic.addEventListener('error', () => console.warn('🎵 Background music load error'));
        backgroundMusic.addEventListener('canplay', () => console.log('🎵 Background music ready'));
    }
    
    // Initialize spin buildup music
    function initializeSpinMusic() {
        spinBuildupMusic.addEventListener('error', () => console.warn('🎵 Spin music load error'));
        spinBuildupMusic.addEventListener('canplay', () => console.log('🎵 Spin music ready'));
        countdownSound.addEventListener('error', () => console.warn('🎵 Countdown sound load error'));
        countdownSound.addEventListener('canplay', () => console.log('🎵 Countdown sound ready'));
    }

    // Initialize tumble sound
    function initializeTumbleSound() {
        tumbleSound.addEventListener('error', () => console.warn('🎵 Tumble sound load error'));
        tumbleSound.addEventListener('canplay', () => console.log('🎵 Tumble sound ready'));
    }

    // Create weighted symbol selection - HEAVILY house-favored with jackpot protection
    function getWeightedRandomSymbol() {
        // If the pot is too low, remove Pepe from the candidate list
        const allowPepe = totalSolPot > JACKPOT_SAFETY_THRESHOLD_SOL;
        
        // Log jackpot protection status (only first time it activates)
        if (!allowPepe && !window.jackpotProtectionLogged) {
            console.log(`🛡️ [Jackpot Protection] Pot below ${JACKPOT_SAFETY_THRESHOLD_SOL} SOL - Pepe disabled`);
            window.jackpotProtectionLogged = true;
        } else if (allowPepe && window.jackpotProtectionLogged) {
            console.log(`🎰 [Jackpot Protection] Pot restored above ${JACKPOT_SAFETY_THRESHOLD_SOL} SOL - Pepe re-enabled`);
            window.jackpotProtectionLogged = false;
        }
        
        const weights = {
            "figure-1": 30,  // S - very common (increased)
            "figure-2": 30,  // O - very common (increased)
            "figure-3": 30,  // L - very common (increased)
            "figure-4": 2,   // Trump - ultra rare (was 8)
            "figure-5": 2,   // Elon - ultra rare (was 8)
            "figure-6": 1,   // Dog - legendary rare (was 4)
            "figure-7": 1,   // Popcat - legendary rare (was 4)
            "figure-8": allowPepe ? 1 : 0    // Pepe - only if pot is safe
        };
        
        // Filter out zero-weight symbols
        const validWeights = Object.fromEntries(
            Object.entries(weights).filter(([symbol, weight]) => weight > 0)
        );
        
        const totalWeight = Object.values(validWeights).reduce((sum, w) => sum + w, 0);
        let random = Math.random() * totalWeight;
        
        for (const [symbol, weight] of Object.entries(validWeights)) {
            random -= weight;
            if (random <= 0) {
                return symbol;
            }
        }
        return "figure-1"; // fallback
    }

        // Helper sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const spinBtn = document.querySelector(".spin-btn[for='btn-spin']");
        const hiddenToggle = document.getElementById("btn-spin");
        const countdownEl = document.querySelector(".countdown");
        const reelWrapper = document.querySelector(".reel-wrapper");


        // ──────────────────────────────────────────────────────────────────────────
        // TOP-LEVEL VARIABLES: Make these global so processCascadingWins can see them
        let allSlots;
        let visibleGrid;
        let isAutoSpinning = false; // Track if we're in an auto-spin sequence
        
        // 🔧 DEBUG: Flag to temporarily disable anti-clustering for testing
        const DISABLE_ANTI_CLUSTERING = false;  // Set to true to test if clustering logic interferes
        
        // ────────────────────────────────────────────────────────────────────────────
        // BULLETPROOF AUTO-SPIN SYSTEM - ELEMENT REFERENCES WITH VALIDATION
        // ────────────────────────────────────────────────────────────────────────────
        
        // First, let's use slot-area as our animation target (since slotContainer doesn't exist)
        const slotContainer = document.querySelector(".slot-area");
        if (!slotContainer) {
            console.warn("⚠️ [AutoSpin] .slot-area not found. Reset animation will be skipped.");
        }

        const autoSpinInput = document.getElementById("autoSpinInput");
        const autoSpinBtn = document.getElementById("autoSpinBtn");
        const stopAutoSpinBtn = document.getElementById("stopAutoSpinBtn");
        const autoSpinProgressWrp = document.getElementById("autoSpinProgressWrapper");
        const autoSpinProgressBar = document.getElementById("autoSpinProgressBar");
        const autoSpinStatus = document.getElementById("autoSpinStatus");
        const autoMusic = document.getElementById("auto-spin-music");

        // Log warnings for any missing elements
        if (!autoSpinInput)       console.warn("⚠️ [AutoSpin] #autoSpinInput not found.");
        if (!autoSpinBtn)         console.warn("⚠️ [AutoSpin] #autoSpinBtn not found.");
        if (!stopAutoSpinBtn)     console.warn("⚠️ [AutoSpin] #stopAutoSpinBtn not found.");
        if (!autoSpinProgressWrp) console.warn("⚠️ [AutoSpin] #autoSpinProgressWrapper not found.");
        if (!autoSpinProgressBar) console.warn("⚠️ [AutoSpin] #autoSpinProgressBar not found.");
        if (!autoSpinStatus)      console.warn("⚠️ [AutoSpin] #autoSpinStatus not found.");
        if (!autoMusic)           console.warn("⚠️ [AutoSpin] #auto-spin-music not found.");

        // Enhanced auto-spin state variables
        let totalSpinsToRun = 0;
        let spinsCompleted = 0;

        // ──────────────────────────────────────────────────────────────────────────
        // BULLETPROOF SYSTEM INITIALIZATION COMPLETE - ELEMENT DISCOVERY LOG
        // ──────────────────────────────────────────────────────────────────────────
        console.log("🛠️ [AutoSpin] Bulletproof auto-spin system v3.0 initialized:");
        console.log("  🎯 slotContainer (.slot-area):", !!slotContainer ? "✅ Found" : "❌ Missing");
        console.log("  🔢 autoSpinInput:", !!autoSpinInput ? "✅ Found" : "❌ Missing");
        console.log("  ▶️ autoSpinBtn:", !!autoSpinBtn ? "✅ Found" : "❌ Missing");
        console.log("  ⏹ stopAutoSpinBtn:", !!stopAutoSpinBtn ? "✅ Found" : "❌ Missing");
        console.log("  📊 autoSpinProgressBar:", !!autoSpinProgressBar ? "✅ Found" : "❌ Missing");
        console.log("  📝 autoSpinStatus:", !!autoSpinStatus ? "✅ Found" : "❌ Missing");
        console.log("  📈 autoSpinProgressWrp:", !!autoSpinProgressWrp ? "✅ Found" : "❌ Missing");
        console.log("  🎵 autoMusic:", !!autoMusic ? "✅ Found" : "❌ Missing");
        console.log("🎉 [AutoSpin] System ready with comprehensive error handling and debugging!");

        // ──────────────────────────────────────────────────────────────────────────
        // BULLETPROOF AUTO-SPIN SYSTEM - HELPER FUNCTIONS WITH COMPREHENSIVE DEBUGGING
        // ──────────────────────────────────────────────────────────────────────────

        // Update the progress bar & status text with validation
        function updateAutoSpinProgress() {
            if (totalSpinsToRun <= 0) return;
            
            const percent = Math.round((spinsCompleted / totalSpinsToRun) * 100);
            if (autoSpinProgressBar) {
                autoSpinProgressBar.style.width = `${percent}%`;
                console.log(`📊 [AutoSpin] Progress: ${percent}%`);
            }
            
            if (autoSpinStatus) {
                autoSpinStatus.textContent = `Spins run: ${spinsCompleted} / ${totalSpinsToRun}`;
            }
        }

        // ──────────────────────────────────────────────────────────────────────────
        // OLD ANIMATION FUNCTIONS REMOVED - Now using bulletproof spinOnce() system
        // ──────────────────────────────────────────────────────────────────────────

        // Stop auto-spin with comprehensive cleanup
        function stopAutoSpin() {
            if (!isAutoSpinning) {
                console.log("ℹ️ [AutoSpin] Stop requested but not currently running.");
                return;
            }
            
            console.log("⏹ [AutoSpin] Stop button clicked. Will end after current spin.");
            isAutoSpinning = false;
            
            // Reset state
            totalSpinsToRun = 0;
            spinsCompleted = 0;

            // Hide progress UI, re-enable inputs/buttons
            if (autoSpinProgressWrp) autoSpinProgressWrp.style.display = "none";
            if (autoSpinBtn) autoSpinBtn.disabled = false;
            if (autoSpinInput) autoSpinInput.disabled = false;
            if (stopAutoSpinBtn) stopAutoSpinBtn.disabled = true;
            
            // Stop auto-spin music
            if (autoMusic) {
                autoMusic.pause();
                autoMusic.currentTime = 0;
            }
            
            // Resume background music
            setTimeout(() => {
                ensureAudioMuteState(backgroundMusic, true);
                backgroundMusic.play().catch(e => console.warn("Background music resume error:", e));
            }, 200);
            
            console.log("✔️ [AutoSpin] Stop cleanup complete.");
        }

        // ────────────────────────────────────────────────────────────────────────────
        // REAL CASINO SYSTEM - Horizontal tumbles with pot-based percentage payouts
        // Based on your payout legend: each symbol pays a percentage of the total pot
        // ────────────────────────────────────────────────────────────────────────────
        
        // The house pot (in SOL) - this gets depleted when players win
        let totalSolPot = 300.0; // Start with 300 SOL (matching your prize pool display)
        
        // Jackpot safety threshold - prevent Pepe from appearing when pot is low
        const JACKPOT_SAFETY_THRESHOLD_SOL = 2.0;
        
        // Your existing symbols (CSS classes)
        const SLOT_SYMBOLS = ["figure-1", "figure-2", "figure-3", "figure-4", "figure-5", "figure-6", "figure-7", "figure-8"];
        
        // Payout percentages for each symbol (based on your legend)
        const PAYOUT_TABLE = {
            "figure-1": 0.00001,  // S (Common)     0.001% → 0.00001 fraction
            "figure-2": 0.00002,  // O (Common)     0.002% → 0.00002 fraction  
            "figure-3": 0.00005,  // L (Common)     0.005% → 0.00005 fraction
            "figure-4": 0.005,    // Trump (Rare)   0.5%   → 0.005 fraction
            "figure-5": 0.005,    // Elon (Rare)    0.5%   → 0.005 fraction
            "figure-6": 0.01,     // Dog (Epic)     1%     → 0.01 fraction
            "figure-7": 0.01,     // Cat (Epic)     1%     → 0.01 fraction
            "figure-8": 1.0       // Pepe (Jackpot) 100%   → 1.0 fraction
        };
        
        // Symbol name mapping for display purposes
        const SYMBOL_NAMES = {
            "figure-1": "S",
            "figure-2": "O", 
            "figure-3": "L",
            "figure-4": "Trump",
            "figure-5": "Elon",
            "figure-6": "Dog",
            "figure-7": "Cat",
            "figure-8": "Pepe"
        };
        
        /**
         * HORIZONTAL MATCH DETECTION - Checks each row for 3+ consecutive identical symbols
         * Returns array of match objects: { row, startCol, length, symbol, positions }
         */
        function findHorizontalMatches(board) {
            const matches = [];
            
            // Check each of the 5 rows
            for (let r = 0; r < 5; r++) {
                // Look for consecutive identical symbols in this row
                let currentSymbol = board[r][0];
                let consecutiveCount = 1;
                let startCol = 0;
                
                for (let c = 1; c < 5; c++) {
                    if (board[r][c] === currentSymbol) {
                        consecutiveCount++;
                    } else {
                        // Check if we had a match of 3+ before the break
                        if (consecutiveCount >= 3) {
                            const positions = [];
                            for (let i = startCol; i < startCol + consecutiveCount; i++) {
                                positions.push({ r, c: i });
                            }
                            matches.push({
                                row: r,
                                startCol: startCol,
                                length: consecutiveCount,
                                symbol: currentSymbol,
                                positions: positions
                            });
                        }
                        // Start new sequence
                        currentSymbol = board[r][c];
                        consecutiveCount = 1;
                        startCol = c;
                    }
                }
                
                // Check for match at end of row
                if (consecutiveCount >= 3) {
                    const positions = [];
                    for (let i = startCol; i < startCol + consecutiveCount; i++) {
                        positions.push({ r, c: i });
                    }
                    matches.push({
                        row: r,
                        startCol: startCol,
                        length: consecutiveCount,
                        symbol: currentSymbol,
                        positions: positions
                    });
                }
            }
            
            return matches;
        }

        /**
         * Given a target fraction t (e.g. 0.50 for 50% of pot),
         * find the optimal "(symbol, k)" such that:
         *   f(k) = sum_{i=1..k}[ symbolPct × (1 + 0.5×(i−1)) ]  ≥ t.
         * Returns the symbol and cascade count with minimal overshoot.
         */
        /**
         * Build rigged board and adjust pot for full 5×5 block system.
         * Picks symbol + cascade count, then pre-scales pot so natural cascades
         * yield exactly targetFraction × originalPot.
         */
        function buildRiggedBoardAndPot(targetFraction) {
            const originalPot = totalSolPot;
            const options = [
                { symbol: "figure-8", pct: 1.0 },   // Pepe (100%)
                { symbol: "figure-6", pct: 0.01 },  // Dog/Cat (1%)
                { symbol: "figure-4", pct: 0.005 }  // Trump/Elon (0.5%)
            ];
            
            let best = null;
            for (let { symbol, pct } of options) {
                for (let k = 1; k <= 30; k++) {
                    const f_k = pct * (k + 0.25 * k * (k - 1));
                    if (f_k >= targetFraction) {
                        const overshoot = f_k - targetFraction;
                        if (!best || overshoot < best.overshoot) {
                            best = { symbol, pct, k, f_k, overshoot };
                        }
                        break;
                    }
                }
            }
            
            if (!best) {
                console.error("❌ Could not find (symbol, k) to reach", targetFraction);
                return null;
            }
            
            // Pre-scale the pot so natural cascade math yields exact target
            totalSolPot = originalPot * (targetFraction / best.f_k);
            updatePotDisplay();
            
            console.log(`🛠️ [Rig] Using ${best.symbol} × ${best.k} cascades (${(best.f_k * 100).toFixed(2)}%) to target ${(targetFraction * 100).toFixed(2)}%`);
            console.log(`💰 [Rig] Pot adjusted: ${originalPot.toFixed(3)} → ${totalSolPot.toFixed(3)} SOL`);
            
            return { symbolClass: best.symbol, cascadeCount: best.k };
        }

        /**
         * Build a solid 5×5 board filled with one symbol
         */
        function buildFullBoardOf(symbol) {
            return Array(5).fill().map(() => Array(5).fill(symbol));
        }

        // ─── Helper 1: Reveal any 5×5 board with tile-reveal animation ───
        async function revealBoard(board) {
            const reels = [...document.querySelectorAll(".reel-wrapper .reel")];
            // Hide all icons first
            reels.forEach(r =>
                r.querySelectorAll(".icon").forEach(i => {
                    i.classList.remove("tile-reveal", "tile-explode");
                    i.classList.add("tile-hidden");
                })
            );
            await sleep(150);

            // Drop in with staggered reveal
            reels.forEach((r, c) => {
                const icons = r.querySelectorAll(".icon");
                for (let r0 = 0; r0 < 5; r0++) {
                    const el = icons[r0 + 3]; // Convert row to icon index
                    if (el) {
                        // 🔧 ASSIGN PROPER ID TO EVERY TILE (including column 4!)
                        el.id = `tile-${r0}-${c}`;
                        
                        el.classList.remove("tile-hidden", "tile-explode");
                        el.className = "icon " + board[r0][c];
                        // Force reflow then add reveal with stagger
                        void el.offsetWidth;
                        setTimeout(() => {
                            el.classList.add("tile-reveal");
                        }, r0 * 30);
                    }
                }
            });
            await sleep(400);
        }

        // ─── Helper 1: Safe board generation ───
        /**
         * Generates a completely fresh 5×5 board with no null values
         */
        function generateRandomBoard() {
            return Array.from({ length: 5 }, () =>
                Array.from({ length: 5 }, () => getWeightedRandomSymbol())
            );
        }

        // ─── Helper 2: Bulletproof Gravity + pure-random refill for exploded columns ───
        /**
         * board[r][c]: 5×5 logical grid (r=0..4, c=0..4)
         * matchPos:    array of {r,c} for every exploded tile
         * allReels:    Array.from(document.querySelectorAll(".reel-wrapper .reel"))
         */
        async function applyGravityAndRandomRefill(board, matchPositions, allReels) {
            // 1) clear exploded spots
            matchPositions.forEach(p => board[p.r][p.c] = null);

            // 2) get unique columns - bulletproof implementation
            const affectedColumns = Array.from(
                new Set(matchPositions.map(p => p.c))
            );

            console.log("🌊 [Gravity] About to refill columns:", affectedColumns);
            
            for (let c of affectedColumns) {
                // 3a) find how deep we exploded - bulletproof implementation
                const rows = matchPositions
                    .filter(p => p.c === c)
                    .map(p => p.r);
                const maxRow = Math.max(...rows);

                // 3b) shift everything above down
                for (let r = maxRow; r > 0; r--) {
                    board[r][c] = board[r - 1][c];
                }

                // 3c) refill only the very top cell
                board[0][c] = getWeightedRandomSymbol();

                // 4) repaint those exact cells via the reel DOM
                const icons = allReels[c].querySelectorAll(".icon");
                for (let r = 0; r <= maxRow; r++) {
                    const el = icons[r + 3];        // your visible window is icons[3..7]
                    if (!el) {
                        console.warn(`❌ [Gravity] Missing icon at column ${c}, row ${r}`);
                        continue;
                    }
                    // Guard against null - never paint a null cell
                    let sym = board[r][c];
                    if (!sym) {
                        sym = getWeightedRandomSymbol();
                        board[r][c] = sym;
                        console.warn(`🔧 [Gravity] Found null at [${r}][${c}], replaced with ${sym}`);
                    }
                    el.className = "icon " + sym;
                    el.classList.remove("tile-explode");
                    if (r === 0) {
                        void el.offsetWidth;
                        el.classList.add("tile-reveal");
                    }
                }
            }

            console.log(`🌊 [Gravity] Applied gravity to ${affectedColumns.length} columns: [${affectedColumns.join(',')}]`);
            await sleep(200);
        }

        /**
         * Builds and reveals one "dead" spin (no 3+ matches), then returns that board.
         * This creates a dramatic "near miss" moment before the final rigged cascade.
         */
        async function dropDeadBoard() {
            const reels = Array.from(document.querySelectorAll(".reel-wrapper .reel"));

            // 1) Hide all icons
            reels.forEach(reel => {
                reel.querySelectorAll(".icon").forEach(icon => {
                    icon.classList.remove("tile-reveal", "tile-explode");
                    icon.classList.add("tile-hidden");
                });
            });
            await sleep(150);

            // 2) Build a board with zero horizontal 3+ matches
            let board;
            do {
                board = generateRandomBoard();
            } while (findHorizontalMatches(board).length > 0);

            console.log("💀 [Rig] Dropping dead board (no matches) for dramatic effect");

            // 3) Reveal that board
            reels.forEach((reel, col) => {
                const icons = reel.querySelectorAll(".icon");
                for (let row = 0; row < 5; row++) {
                    const iconIndex = row + 3; // Convert to icon index
                    const icon = icons[iconIndex];
                    if (icon) {
                        // 🔧 ASSIGN PROPER ID TO EVERY TILE (including column 4!)
                        icon.id = `tile-${row}-${col}`;
                        
                        icon.classList.remove("tile-hidden", "tile-explode");
                        // Guard against null - never paint a null cell
                        let sym = board[row][col];
                        if (!sym) {
                            sym = getWeightedRandomSymbol();
                            board[row][col] = sym;
                            console.warn(`🔧 [DeadBoard] Found null at [${row}][${col}], replaced with ${sym}`);
                        }
                        icon.className = "icon " + sym;
                        void icon.offsetWidth;
                        setTimeout(() => {
                            icon.classList.add("tile-reveal");
                        }, row * 30);
                    }
                }
            });
            await sleep(500);

            // Clean up reveal classes
            reels.forEach(reel => {
                reel.querySelectorAll(".icon").forEach(icon => {
                    icon.classList.remove("tile-reveal");
                });
            });

            // Brief pause to let player see the "miss"
            await sleep(300);

            return board;
        }

        // ─── The improved rigged spin routine ───
        async function runRiggedSlotSpin(rawPercent) {
            // 1) Normalize input to a true fraction:
            let t = rawPercent;
            if (t >= 1) t /= 100;           // "1" → 0.01, "25" → 0.25
            const targetFraction = t;

            // 2) Shrink the pot & pick symbol/k (we won't use the symbol for 1%)
            const rig = buildRiggedBoardAndPot(targetFraction);
            if (!rig) return { totalPayoutSol: 0 };
            let { symbolClass, cascadeCount } = rig;

            // Check for Pepe jackpot safety
            if (symbolClass === "figure-8" && totalSolPot <= JACKPOT_SAFETY_THRESHOLD_SOL) {
                console.log("🚫 [Rig] Pot too low for Pepe jackpot - showing dead spin instead");
                await dropDeadBoard();
                return { totalPayoutSol: 0 };
            }

            // ─── SPECIAL CASE: Exactly 1% rigs ─────────────────────────
            const isOnePercent = Math.abs(targetFraction - 0.01) < 1e-9;
            if (isOnePercent) {
                // Force exactly 5 cascades, regardless of what buildRiggedBoardAndPot said:
                cascadeCount = 5;

                // Build a 5×5 board of S → O → L → S → O
                const baseSyms = ["figure-1","figure-2","figure-3"];
                var fullBoard = Array.from({ length: 5 }, (_, rowIndex) => {
                    // Round-robin through S,O,L
                    const sym = baseSyms[rowIndex % baseSyms.length];
                    return Array(5).fill(sym);
                });
                console.log("🎯 [Rig] 1% rig - built 5 rows of base symbols");
            } else {
                // Fallback: your normal fullBoard of symbolClass
                var fullBoard = buildFullBoardOf(symbolClass);
                console.log(`🛠️ [Rig] Standard rig - built 5×5 block of ${symbolClass}`);
            }

            console.log("⏳ [Rig] Initial board →", fullBoard);
            
            // 3) Reveal that initial board:
            await revealBoard(fullBoard);

            // 4) Execute cascades - different logic for 1% vs standard rigs:
            let currentBoard = fullBoard.map(r => r.slice());
            let totalPayoutSol = 0;
            const allWins = []; // Track wins for popup display
            const reels = Array.from(document.querySelectorAll(".reel-wrapper .reel"));

            if (isOnePercent) {
                // ─── MANUAL 1% RIG CASCADES ───
                // Manually explode each of the five rows in order to guarantee all 5 tumbles
                for (let row = 0; row < 5; row++) {
                    console.log(`🔄 [Rig][1%] Manual cascade ${row+1}/5 - exploding row ${row}`);

                    // 1) Explode the entire row:
                    const matchPositions = Array.from({length: 5}, (_, c) => ({ r: row, c }));
                    matchPositions.forEach(p => {
                        const el = document.querySelector(
                            `.reel-wrapper .reel:nth-child(${p.c+1}) .icon:nth-child(${p.r+3})`
                        );
                        if (el) createSymbolExplosion(el);
                        currentBoard[p.r][p.c] = null;
                    });

                    // 2) Calculate payout for this row:
                    const sym = fullBoard[row][0];                  // e.g. "figure-1"
                    const pctMap = { "figure-1":0.001, "figure-2":0.002, "figure-3":0.005 };
                    const pct = pctMap[sym];
                    const mult = 1 + 0.5 * row;                     // 1.0, 1.5, 2.0, 2.5, 3.0
                    const win = totalSolPot * (pct * (5/3) * mult);
                    totalPayoutSol += win;
                    totalSolPot -= win;
                    
                    // Track win for popup display
                    const symbolName = SYMBOL_NAMES[sym] || sym;
                    allWins.push({
                        outcome: symbolName,
                        count: 5,
                        consecutiveColumns: 5,
                        cascade: row + 1
                    });
                    
                    console.log(`   → Paid ${win.toFixed(6)} SOL for 5x ${sym} (mult: ${mult.toFixed(1)}x)`);

                    await sleep(300);

                    // 3) Gravity + random refill on columns 0..4:
                    for (let c = 0; c < 5; c++) {
                        // shift down
                        for (let r = row; r > 0; r--) {
                            currentBoard[r][c] = currentBoard[r-1][c];
                        }
                        // top is random
                        currentBoard[0][c] = getWeightedRandomSymbol();

                        // update DOM
                        for (let r = 0; r <= row; r++) {
                            const tile = document.getElementById(`tile-${r}-${c}`);
                            if (!tile) continue;
                            // Guard against null - never paint a null cell
                            let sym = currentBoard[r][c];
                            if (!sym) {
                                sym = getWeightedRandomSymbol();
                                currentBoard[r][c] = sym;
                                console.warn(`🔧 [Rig] Found null at [${r}][${c}], replaced with ${sym}`);
                            }
                            tile.className = "icon " + sym;
                            if (r === 0) {
                                void tile.offsetWidth;
                                tile.classList.add("tile-reveal");
                            }
                        }
                    }

                    if (tumbleSound) { tumbleSound.currentTime = 0; tumbleSound.play(); }
                    await sleep(200);
                }
            } else {
                // ─── STANDARD RIG CASCADES ───
                // Use the existing match-finding logic for non-1% rigs
                for (let run = 0; run < cascadeCount; run++) {
                    console.log(`🔄 [Rig][Standard] Cascade ${run+1} of ${cascadeCount}`);

                    // Find whichever row still has a full-row match:
                    const matches = findHorizontalMatches(currentBoard);
                    if (!matches.length) {
                        console.warn("❌ No more matches! This shouldn't happen on rigged board.");
                        break;
                    }
                    // Pick the one on the topmost un-exploded row:
                    const m = matches.reduce((best, cur) =>
                        cur.row < best.row ? cur : best
                    , matches[0]);

                    // Explode all symbols in that row:
                    m.positions.forEach(p => {
                        const el = document.querySelector(
                            `.reel-wrapper .reel:nth-child(${p.c+1}) .icon:nth-child(${p.r+4})`
                        );
                        if (el) {
                            el.classList.add("tile-explode");
                            if (typeof createSymbolExplosion === 'function') {
                                createSymbolExplosion(el);
                            }
                        }
                    });

                    // Compute payout for standard rigs:
                    const pct = PAYOUT_TABLE[m.symbol] || 0;
                    const mult = 1 + 0.5 * run;
                    const winFrac = pct * (m.length/3) * mult;
                    const win = totalSolPot * winFrac;
                    totalPayoutSol += win;
                    totalSolPot -= win;
                    
                    // Track win for popup display
                    const symbolName = SYMBOL_NAMES[m.symbol] || m.symbol;
                    allWins.push({
                        outcome: symbolName,
                        count: m.length,
                        consecutiveColumns: 5,
                        cascade: run + 1
                    });
                    
                    console.log(`   → Paid ${win.toFixed(6)} SOL for ${m.length}x ${m.symbol}`);

                    // Wait for explosion animation
                    await sleep(300);

                    // Gravity + random refill for those columns:
                    await applyGravityAndRandomRefill(currentBoard, m.positions, reels);

                    if (typeof tumbleSound !== 'undefined' && tumbleSound) { 
                        tumbleSound.currentTime = 0; 
                        tumbleSound.play().catch(e => console.warn("Tumble sound failed:", e)); 
                    }
                    
                    // Clean up reveal classes
                    reels.forEach(reel => {
                        reel.querySelectorAll(".icon").forEach(icon => {
                            icon.classList.remove("tile-reveal");
                        });
                    });
                    
                    await sleep(200);
                }
            }

            // 5) Final "you won" popup & feed:
            if (totalPayoutSol > 0) {
                try {
                    // Calculate percentage of original pot for display
                    const originalPot = totalPayoutSol / targetFraction;
                    const totalPercentage = (totalPayoutSol / originalPot) * 100;
                    
                    // 1️⃣ Show the dramatic popup
                    showWinPopup(allWins, totalPayoutSol, totalPercentage, cascadeCount);
                    
                    // 2️⃣ Update running totals
                    const oldSol = runningSolTotal;
                    runningSolTotal += totalPayoutSol;
                    $('#counter-sol').prop('Counter', oldSol).animate({
                        Counter: runningSolTotal
                    }, {
                        duration: 800,
                        easing: 'swing',
                        step: function(now) { $(this).text(now.toFixed(6)); }
                    });
                    
                    // USD conversion if available
                    const winUsd = currentSolPriceUsd ? totalPayoutSol * currentSolPriceUsd : 0;
                    if (currentSolPriceUsd) {
                        const oldUsd = runningUsdTotal;
                        runningUsdTotal += winUsd;
                        $('#counter-usd').prop('Counter', oldUsd).animate({
                            Counter: runningUsdTotal
                        }, {
                            duration: 800,
                            easing: 'swing', 
                            step: function(now) { $(this).text(now.toFixed(2)); }
                        });
                    }
                    
                    // 3️⃣ Push to live wins feed
                    if (typeof addLiveWin === 'function') {
                        const winType = cascadeCount >= 3 ? "MEGA WIN" : "YOU WIN";
                        addLiveWin(totalPayoutSol, winUsd, true, isOnePercent ? "Natural Win" : "Rigged Win");
                    }
                    
                    // 4️⃣ Update pot display
                    updatePotDisplay();
                    
                    // 5️⃣ Update game stats
                    if (typeof updateGameStats === 'function') {
                        updateGameStats(totalPercentage, true, allWins);
                    }
                    
                    if (isWalletConnected && typeof recordWin === 'function') {
                        recordWin(totalPayoutSol.toFixed(6), isOnePercent ? "Natural Win" : "Rigged Win");
                    }
                } catch (error) {
                    console.warn("⚠️ [Rig] Error in win integration:", error);
                }
            }

            console.log(`✅ [Rig] Rigged spin complete: totalPayoutSol=${totalPayoutSol.toFixed(6)} SOL`);
            return { totalPayoutSol: totalPayoutSol };
        }



        /**
         * ANIMATION SYSTEM WITH HORIZONTAL TUMBLES & POT-BASED PAYOUTS
         * - Initial spin + drop-in animation
         * - Detect horizontal 3+ consecutive matches
         * - Pay out from pot based on symbol percentage
         * - Explode matching symbols and refill entire rows
         * - Repeat until no more matches
         */
        async function animateSlotSpin() {
            console.log("🎬 [Animation] Starting horizontal tumble system...");
            console.log("💰 [Pot] Starting pot:", totalSolPot.toFixed(3), "SOL");
            
            // 1) Get all reels and validate structure
            const allReels = Array.from(document.querySelectorAll(".reel-wrapper .reel"));
            if (allReels.length !== 5) {
                console.error("❌ Expected 5 reels, found", allReels.length);
                return { board: null, totalPayoutSol: 0 };
            }
            
            // 2) HIDE PHASE: Push all visible icons off-screen instantly
            allReels.forEach(reel => {
                const icons = reel.querySelectorAll(".icon");
                for (let i = 3; i <= 7; i++) { // indices 3-7 are visible
                    const icon = icons[i];
                    if (icon) {
                        icon.classList.remove("tile-reveal", "tile-explode"); // cleanup
                        icon.classList.add("tile-hidden");    // hide instantly
                    }
                }
            });
            console.log("🔄 [Animation] All tiles hidden");
            
            // 3) Wait for player to see cleared reels
            await new Promise(r => setTimeout(r, 150));
            
            // 4) Check for rigged spin and handle accordingly
            let currentBoard;
            let isRiggedSpin = false;
            let riggedPayoutTotal = 0;
            
            // Check localStorage for rig config if not already set
            if (!window.rigConfig) {
                try {
                    const storedRig = localStorage.getItem('rigConfig');
                    if (storedRig) {
                        const parsed = JSON.parse(storedRig);
                        // Only use if less than 5 minutes old
                        if (Date.now() - parsed.timestamp < 300000) {
                            window.rigConfig = parsed;
                            console.log('🛠️ [Rig] Loaded from localStorage:', window.rigConfig);
                        } else {
                            localStorage.removeItem('rigConfig');
                        }
                    }
                } catch (err) {
                    console.warn('⚠️ [Rig] Error loading from localStorage:', err);
                }
            }
            
            // Check if this is a rigged spin
            if (window.rigConfig && 
                isWalletConnected && 
                typeof userPublicKey === 'string' && 
                window.rigConfig.wallet === userPublicKey) {
                
                // Get the raw percentage value (e.g., 1 for 1%, 50 for 50%)
                const rawPercent = window.rigConfig.winPercent;
                
                console.log(`🛠️ [Rig] Rigged spin detected for ${userPublicKey} → ${rawPercent}%`);
                
                // Clear rig config (one-time use)
                window.rigConfig = null;
                localStorage.removeItem('rigConfig');
                
                // Run the full 5×5 rigged spin
                const rigResult = await runRiggedSlotSpin(rawPercent);
                if (rigResult) {
                    isRiggedSpin = true;
                    riggedPayoutTotal = rigResult.totalPayoutSol;
                    console.log(`✅ [Rig] Rigged spin complete. Actual payout: ${riggedPayoutTotal.toFixed(6)} SOL`);
                    
                    // Skip normal processing and return early with rigged results
                    return { 
                        board: null, // Rigged spins don't need to return board state
                        totalPayoutSol: riggedPayoutTotal,
                        tumbleCount: 0 
                    };
                }
            }
            
            // Normal random board generation (only for non-rigged spins)
            currentBoard = generateRandomBoard();
            console.log("🎲 [Animation] Generated random board:", currentBoard);
            
            // 5) REVEAL PHASE: Normal spins only (rigged spins already returned)
            allReels.forEach((reel, reelIndex) => {
                const icons = reel.querySelectorAll(".icon");
                for (let row = 0; row < 5; row++) {
                    const iconIndex = row + 3; // visible icons at indices 3-7
                    const icon = icons[iconIndex];
                    if (icon) {
                        const newSymbol = currentBoard[row][reelIndex];
                        
                        // 🔧 ASSIGN PROPER ID TO EVERY TILE (including column 4!)
                        icon.id = `tile-${row}-${reelIndex}`;
                        
                        // Update CSS class for new symbol
                        icon.className = "icon " + newSymbol;
                        
                        // Staggered drop-in animation
                        const delay = row * 50; // 50ms between rows
                        setTimeout(() => {
                            icon.classList.remove("tile-hidden");
                            icon.classList.add("tile-reveal");
                        }, delay);
                    }
                }
            });
            
            // 6) Wait for initial drop-in animations to complete
            await new Promise(r => setTimeout(r, 750)); // 500ms animation + 250ms stagger buffer
            
            // Clean up initial reveal classes
            allReels.forEach(reel => {
                const icons = reel.querySelectorAll(".icon");
                for (let i = 3; i <= 7; i++) {
                    const icon = icons[i];
                    if (icon) icon.classList.remove("tile-reveal");
                }
            });
            
            // ──────────────────────────────────────────────────────────────────────────
            // 7) TUMBLE PHASE: Process cascades for normal spins only
            // ──────────────────────────────────────────────────────────────────────────
            let tumbleCount = 0;
            let totalPayoutThisSpin = 0;
            const maxTumbles = 10; // Prevent infinite loops
            
            while (tumbleCount < maxTumbles) {
                // 7a) Find any horizontal matches (3+ consecutive in any row)
                const matches = findHorizontalMatches(currentBoard);
                if (matches.length === 0) {
                    console.log("🎯 [Animation] No more horizontal matches found");
                    break; // No horizontal matches → exit tumble loop
                }
                
                tumbleCount++;
                console.log(`💥 [Animation] Tumble #${tumbleCount}: Found ${matches.length} horizontal matches`);
                
                    // 7b) Normal payout processing
                for (const match of matches) {
                    const { symbol, length, positions } = match;
                    const symbolName = SYMBOL_NAMES[symbol] || symbol;
                    
                    // Calculate payout from pot
                    const payoutFraction = PAYOUT_TABLE[symbol] || 0;
                    const lengthMultiplier = length; // 3-symbol = 1x, 4-symbol = 1.33x, 5-symbol = 1.67x
                    const basePayout = totalSolPot * payoutFraction;
                    const actualPayout = basePayout * (lengthMultiplier / 3); // Scale by length
                    
                    // Deduct from pot and track total
                    totalSolPot -= actualPayout;
                    totalPayoutThisSpin += actualPayout;
                    
                    console.log(`💰 [Payout] ${length}x ${symbolName} → ${actualPayout.toFixed(6)} SOL (${(payoutFraction * 100).toFixed(3)}% × ${lengthMultiplier}/3). Pot now: ${totalSolPot.toFixed(3)} SOL`);
                    
                    // Animate matched tiles with explode effect
                    positions.forEach(({ r, c }) => {
                        const reel = allReels[c];
                        const icons = reel.querySelectorAll(".icon");
                        const iconIndex = r + 3; // visible icons at indices 3-7
                        const icon = icons[iconIndex];
                        if (icon) {
                            icon.classList.add("tile-explode");
                        }
                    });
                }
                
                // 7c) Wait for explode animation (300ms)
                await new Promise(r => setTimeout(r, 300));
                
                // 7d) Gravity + random refill only on exploded columns
                const allMatchPositions = matches.flatMap(m => m.positions);
                await applyGravityAndRandomRefill(currentBoard, allMatchPositions, allReels);
                
                // 7e) Clean up reveal classes and brief pause between tumbles
                allReels.forEach(reel => {
                    const icons = reel.querySelectorAll(".icon");
                    for (let i = 3; i <= 7; i++) {
                        const icon = icons[i];
                        if (icon) icon.classList.remove("tile-reveal");
                    }
                });
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            if (tumbleCount >= maxTumbles) {
                console.warn("⚠️ [Animation] Maximum tumbles reached, stopping to prevent infinite loop");
            }
            
            console.log(`✨ [Animation] Animation complete with ${tumbleCount} tumbles!`);
            console.log(`💰 [Pot] Final pot: ${totalSolPot.toFixed(3)} SOL`);
            console.log(`💸 [Payout] Total paid this spin: ${totalPayoutThisSpin.toFixed(6)} SOL`);
            
            return { 
                board: currentBoard, 
                totalPayoutSol: totalPayoutThisSpin,
                tumbleCount: tumbleCount 
            }; // Return grid state + payout info
        }
        
        /**
         * PAYMENT SYSTEM - Handles real SOL payouts from the pot
         */
        async function payOutToPlayer(payoutSol) {
            if (payoutSol <= 0) return;
            
            console.log(`💰 [Payout] Processing ${payoutSol.toFixed(6)} SOL payout to player`);
            
            // TODO: Replace with your actual wallet transfer code
            // Example: await phantomWallet.sendTransaction({ amount: payoutSol, to: playerAddress });
            
            // Update running totals for display
            const oldSol = runningSolTotal;
            runningSolTotal += payoutSol;
            $('#counter-sol').prop('Counter', oldSol).animate({
                Counter: runningSolTotal
            }, {
                duration: 800,
                easing: 'swing',
                step: function(now) { $(this).text(now.toFixed(6)); }
            });
            
            // USD conversion if available
            const winUsd = currentSolPriceUsd ? payoutSol * currentSolPriceUsd : 0;
            if (currentSolPriceUsd) {
                const oldUsd = runningUsdTotal;
                runningUsdTotal += winUsd;
                $('#counter-usd').prop('Counter', oldUsd).animate({
                    Counter: runningUsdTotal
                }, {
                    duration: 800,
                    easing: 'swing',
                    step: function(now) { $(this).text(now.toFixed(2)); }
                });
            }
            
            // Update the pot display immediately
            updatePotDisplay();
            
            // Integrate with live wins system
            try {
                // Determine win type based on payout size
                let winType = "Standard Win";
                if (payoutSol >= 100) {
                    winType = "PEPE JACKPOT";
                } else if (payoutSol >= 1) {
                    winType = "Big Win";
                } else if (payoutSol >= 0.1) {
                    winType = "Epic Win";
                } else if (payoutSol >= 0.01) {
                    winType = "Rare Win";
                }
                
                addLiveWin(payoutSol, winUsd, true, winType);
                
                // Update game stats for results tracking
                if (typeof updateGameStats === 'function') {
                    const payoutPercentage = ((payoutSol / 300) * 100); // Convert back to percentage of original pot
                    updateGameStats(payoutPercentage, true, [{ symbol: "horizontal-match" }]);
                }
                
                // Record win for crypto integration if connected
                if (isWalletConnected && typeof recordWin === 'function') {
                    recordWin(payoutSol.toFixed(6), winType);
                }
            } catch (error) {
                console.warn("⚠️ [Payout] Error in live systems integration:", error);
            }
        }
        
        /**
         * UPDATE POT DISPLAY - Syncs the displayed pot with the actual pot
         */
        function updatePotDisplay() {
            // Update top prize pool display
            const topPoolAmount = document.getElementById('top-pool-amount');
            if (topPoolAmount) {
                topPoolAmount.textContent = Math.floor(totalSolPot).toLocaleString();
            }
            
            // Update USD equivalent
            const topPoolUsd = document.getElementById('top-pool-usd');
            if (topPoolUsd && currentSolPriceUsd) {
                const usdValue = Math.floor(totalSolPot * currentSolPriceUsd);
                topPoolUsd.textContent = usdValue.toLocaleString();
            }
        }
        
        /**
         * MAIN SPIN FUNCTION - Horizontal tumbles with real pot-based payouts
         * This implements the true casino experience with percentage-based rewards
         */
        async function spinOnce({ skipBuildup = false } = {}) {
            console.log("▶️ [SpinOnce] Started - Horizontal Tumble Casino System");
            
            // 1) Disable buttons to prevent spam
            hiddenToggle.disabled = true;
            if (autoSpinBtn) autoSpinBtn.disabled = true;
            
            // 2) Optional buildup sequence for manual spins
            if (!skipBuildup) {
                console.log("🎬 [SpinOnce] Playing buildup sequence...");
                
                spinBuildupMusic.currentTime = 0;
                ensureAudioMuteState(spinBuildupMusic, true);
                spinBuildupMusic.play().catch(e => console.warn("Spin music error:", e));
                reelWrapper.classList.add("buildup");

                // Quick buildup: "R U REDY?" → 3-2-1 → "BOUT TO GET RICH?"
                countdownEl.textContent = "R U REDY?";
                countdownEl.style.opacity = "1";
                countdownEl.classList.add("pulse");
                await sleep(800);
                countdownEl.classList.remove("pulse");
                countdownEl.style.opacity = "0";
                await sleep(150);

                let counter = 3;
                while (counter > 0) {
                    countdownSound.currentTime = 0;
                    ensureAudioMuteState(countdownSound, false);
                    countdownSound.play().catch(e => console.warn("Countdown sound failed:", e));
                    countdownEl.textContent = counter;
                    countdownEl.style.opacity = "1";
                    countdownEl.classList.add("pulse");
                    await sleep(500);
                    countdownEl.classList.remove("pulse");
                    await sleep(150);
                    counter--;
                }

                countdownEl.textContent = "BOUT TO GET RICH?";
                countdownEl.style.opacity = "1";
                countdownEl.classList.add("pulse");
                await sleep(800);
                countdownEl.classList.remove("pulse");
                countdownEl.style.opacity = "0";
                await sleep(100);

                countdownEl.textContent = "";
                reelWrapper.classList.remove("buildup");
            } else {
                // Auto-spin: just play the music
                autoMusic.currentTime = 0;
                ensureAudioMuteState(autoMusic, true);
                autoMusic.play().catch(e => console.warn("Autospin music failed:", e));
            }
            
            // ─── RIGGED SPIN CHECK ────────────────────────────────────────────────
            if (isWalletConnected && typeof userPublicKey === 'string') {
                const rigPercent = await getAndClearRig(userPublicKey);
                if (rigPercent !== null) {
                    console.log(`🥷 [Rig] Detected admin rig: ${rigPercent}%`);
                    await runRiggedSpin(rigPercent);

                    // Cleanup & re-enable controls (mirrors end-of-spin)
                    spinBuildupMusic.pause();
                    spinBuildupMusic.currentTime = 0;
                    autoMusic.pause();
                    autoMusic.currentTime = 0;

                    hiddenToggle.disabled = false;
                    if (autoSpinBtn) autoSpinBtn.disabled = false;

                    setTimeout(() => {
                        ensureAudioMuteState(backgroundMusic, true);
                        backgroundMusic.play().catch(e => console.warn('Background music resume error:', e));
                    }, 300);

                    console.log("✅ [SpinOnce] Complete - rigged spin path");
                    return; // Skip normal RNG logic
                }
            }
            
            // 3) Run the horizontal tumble animation system and get real payouts
            const animationResult = await animateSlotSpin();
            const totalPayoutSol = animationResult.totalPayoutSol || 0;
            const tumbleCount = animationResult.tumbleCount || 0;
            
            // 4) Process the payout through the payment system
            if (totalPayoutSol > 0) {
                await payOutToPlayer(totalPayoutSol);
            }
            
            // 5) Display results based on actual winnings from the pot
            const resultEl = document.getElementById("result");
            let resultText = "";
            let resultClass = "result-display";
            
            if (totalPayoutSol > 0) {
                if (totalPayoutSol >= 50) {
                    // MEGA JACKPOT (likely Pepe or multiple big wins)
                    resultText = `🎰 MEGA JACKPOT! +${totalPayoutSol.toFixed(6)} SOL from the pot!`;
                    resultClass = "result-display win mega-win";
                } else if (totalPayoutSol >= 1) {
                    // BIG WIN
                    resultText = `🎉 BIG WIN! +${totalPayoutSol.toFixed(6)} SOL from the pot!`;
                    resultClass = "result-display win mega-win";
                } else if (totalPayoutSol >= 0.001) {
                    // STANDARD WIN
                    resultText = `💰 WIN! +${totalPayoutSol.toFixed(6)} SOL from the pot!`;
                    resultClass = "result-display win";
                } else {
                    // TINY WIN (very small symbols)
                    resultText = `✨ Small Win! +${totalPayoutSol.toFixed(8)} SOL from the pot!`;
                    resultClass = "result-display win";
                }
                
                if (tumbleCount > 1) {
                    resultText += ` (${tumbleCount} cascades!)`;
                }
            } else {
                // No win this time
                resultText = `❌ No horizontal matches. Better luck next spin!`;
                resultClass = "result-display no-win";
            }
            
            if (resultEl) {
                resultEl.innerHTML = resultText;
                resultEl.className = resultClass;
            }
            
            // Log the outcome for debugging
            console.log(`🎯 [SpinOnce] Complete: Paid ${totalPayoutSol.toFixed(6)} SOL, ${tumbleCount} tumbles, Pot: ${totalSolPot.toFixed(3)} SOL`);
            
            // 6) Cleanup and re-enable controls
            spinBuildupMusic.pause();
            spinBuildupMusic.currentTime = 0;
            autoMusic.pause();
            autoMusic.currentTime = 0;
            
            if (!isAutoSpinning) {
                hiddenToggle.disabled = false;
                if (autoSpinBtn) autoSpinBtn.disabled = false;
            }
            
            // Resume background music
            setTimeout(() => {
                ensureAudioMuteState(backgroundMusic, true);
                backgroundMusic.play().catch(e => console.warn('Background music resume error:', e));
            }, 300);
            
            console.log("✅ [SpinOnce] Complete - Real Casino System!");
        }

        // ──────────────────────────────────────────────────────────────────────────
        // MANUAL SPIN NOW USES BULLETPROOF spinOnce() - Old performManualSpin() removed
        // ──────────────────────────────────────────────────────────────────────────

        // BULLETPROOF manual spin event listener - uses the guaranteed spinOnce()
        spinBtn.addEventListener("click", async () => {
            // Reset running totals for manual spins (so they start fresh)
            runningSolTotal = 0;
            runningUsdTotal = 0;
            $('#counter-sol').text('0');
            $('#counter-usd').text('0');
            
            console.log("🎯 [ManualSpin] Manual spin button clicked!");
            
            try {
                // Use the bulletproof spinOnce() with full buildup experience
                await spinOnce({ skipBuildup: false });
                console.log("✅ [ManualSpin] Manual spin completed successfully!");
            } catch (error) {
                console.error("❌ [ManualSpin] Manual spin failed:", error);
                // Re-enable the button even if spin fails
                hiddenToggle.disabled = false;
                if (autoSpinBtn) autoSpinBtn.disabled = false;
            }
        });

        // ────────────────────────────────────────────────────────────────────────────
        // ENHANCED AUTO-SPIN SYSTEM V2.0 - MAIN LOGIC & EVENT HANDLERS
        // ────────────────────────────────────────────────────────────────────────────

        // Bulletproof auto-spin main function with comprehensive validation & debugging
        async function startAutoSpin(count) {
            // 1) Validate count first
            count = parseInt(count, 10);
            if (isNaN(count) || count < 1) {
                console.warn("⚠️ [AutoSpin] Invalid spin count:", count);
                return;
            }

            // 2) If already spinning, ignore this click
            if (isAutoSpinning) {
                console.log("ℹ️ [AutoSpin] Already running; ignoring new request.");
                return;
            }

            console.log(`▶️ [AutoSpin] Starting ${count} spins…`);

            // ZERO OUT our running totals (so the counters start at 0 for this Auto-Spin session)
            runningSolTotal = 0;
            runningUsdTotal = 0;
            $('#counter-sol').text('0');
            $('#counter-usd').text('0');

            // 3) Initialize state
            isAutoSpinning = true;
            totalSpinsToRun = count;
            spinsCompleted = 0;
            updateAutoSpinProgress();

            // 4) Show/hide UI, toggle buttons
            if (autoSpinProgressWrp) autoSpinProgressWrp.style.display = "block";
            if (autoSpinBtn) autoSpinBtn.disabled = true;
            if (autoSpinInput) autoSpinInput.disabled = true;
            if (stopAutoSpinBtn) stopAutoSpinBtn.disabled = false;
            hiddenToggle.disabled = true; // Disable manual spin

            // 5) Start auto-spin music
            backgroundMusic.pause();
            if (autoMusic) {
                autoMusic.currentTime = 0;
                ensureAudioMuteState(autoMusic, true);
                autoMusic.play().catch((e) => console.warn("Autospin music failed:", e));
            }

            // 6) Loop through each spin with comprehensive error handling
            for (let i = 0; i < count; i++) {
                if (!isAutoSpinning) {
                    console.log("⏹ [AutoSpin] Stopped early at iteration", i + 1);
                    break;
                }

                console.log(`🔢 [AutoSpin] Loop iteration ${i + 1} / ${count}`);

                // 6a) Brief pause between auto-spins for visual separation
                await sleep(200);

                // 6b) Trigger the actual spin with error handling
                try {
                    console.log(`🎰 [AutoSpin] Calling spinOnce() for spin #${i + 1}`);
                    await spinOnce({ skipBuildup: true });
                    console.log(`✅ [AutoSpin] spinOnce() finished for spin #${i + 1}`);
                } catch (spinErr) {
                    console.error("❌ [AutoSpin] spinOnce() threw an error:", spinErr);
                    break;
                }

                // 6c) Update progress count
                spinsCompleted++;
                updateAutoSpinProgress();
            }

            // 7) Cleanup after loop ends (finished all or stopped early)
            isAutoSpinning = false;
            totalSpinsToRun = 0;
            spinsCompleted = 0;

            console.log("✔️ [AutoSpin] Loop complete.");

            // Hide progress UI, re-enable inputs/buttons
            if (autoSpinProgressWrp) autoSpinProgressWrp.style.display = "none";
            if (autoSpinBtn) autoSpinBtn.disabled = false;
            if (autoSpinInput) autoSpinInput.disabled = false;
            if (stopAutoSpinBtn) stopAutoSpinBtn.disabled = true;
            hiddenToggle.disabled = false; // Re-enable manual spin

            // Stop auto-spin music and resume background
            if (autoMusic) {
                autoMusic.pause();
                autoMusic.currentTime = 0;
            }
            
            setTimeout(() => {
                ensureAudioMuteState(backgroundMusic, true);
                backgroundMusic.play().catch(e => console.warn("Background music resume error:", e));
            }, 200);

            console.log("🎉 [AutoSpin] Bulletproof sequence complete!");
        }

        // ──────────────────────────────────────────────────────────────────────────
        // BULLETPROOF EVENT LISTENERS WITH VALIDATION
        // ──────────────────────────────────────────────────────────────────────────

        // Start Auto-Spin button with input validation
        if (autoSpinBtn) {
            autoSpinBtn.addEventListener("click", () => {
                const count = autoSpinInput ? autoSpinInput.value : null;
                console.log(`🎯 [AutoSpin] Start button clicked, input value: "${count}"`);
                startAutoSpin(count);
            });
        } else {
            console.warn("⚠️ [AutoSpin] Start button event listener skipped (button not found)");
        }

        // Allow "Enter" in the input to start auto-spin as well
        if (autoSpinInput) {
            autoSpinInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    console.log(`⌨️ [AutoSpin] Enter key pressed, input value: "${autoSpinInput.value}"`);
                    if (autoSpinBtn) autoSpinBtn.click();
                }
            });
        } else {
            console.warn("⚠️ [AutoSpin] Input enter-key listener skipped (input not found)");
        }

        // Stop button with state checking
        if (stopAutoSpinBtn) {
            stopAutoSpinBtn.addEventListener("click", () => {
                console.log("🛑 [AutoSpin] STOP button clicked!");
                stopAutoSpin();
            });
        } else {
            console.warn("⚠️ [AutoSpin] Stop button event listener skipped (button not found)");
        }
                
                            // ────────────────────────────────────────────────────────────────────────────
                // POT-BASED HORIZONTAL TUMBLE SYSTEM
                // Real casino mechanics: horizontal matches pay from an actual SOL pot
                // ────────────────────────────────────────────────────────────────────────────
                
                // Global variable to store last win data for tweeting
                let lastWinData = null;

                // Function to show dramatic win popup
                function showWinPopup(allWins, totalPayout, totalPercentage, cascadeCount) {
                    // Store win data globally for tweeting
                    lastWinData = {
                        allWins: allWins,
                        totalPayout: totalPayout,
                        totalPercentage: totalPercentage,
                        cascadeCount: cascadeCount,
                        timestamp: new Date()
                    };

                    const winPopup = document.getElementById('win-popup');
                    const winTitle = document.getElementById('win-popup-title');
                    const winSymbols = document.getElementById('win-symbols');
                    const winExplanation = document.getElementById('win-explanation');
                    const winPayoutEl = document.getElementById('win-payout');
                    const winBreakdown = document.getElementById('win-breakdown');
                    
                    // Determine if this is a mega win
                    const isMegaWin = cascadeCount >= 3 || totalPercentage >= 0.1;
                    
                    // Set up the popup content
                    if (isMegaWin) {
                        winPopup.classList.add('mega-win');
                        winTitle.innerHTML = `🎰 MEGA WIN! ${cascadeCount} CASCADES!`;
                    } else {
                        winPopup.classList.remove('mega-win');
                        winTitle.innerHTML = `🎰 YOU WIN!`;
                    }
                    
                    // Group wins by type
                    const winsByType = {};
                    for (const win of allWins) {
                        if (!winsByType[win.outcome]) winsByType[win.outcome] = [];
                        winsByType[win.outcome].push(win);
                    }
                    
                    // Create symbols display
                    const symbolsText = Object.entries(winsByType)
                        .map(([outcome, wins]) => `${wins.length}× ${outcome}`)
                        .join(' • ');
                    winSymbols.innerHTML = symbolsText;
                    
                    // Create explanation
                    let explanation = `You achieved ${cascadeCount} cascade${cascadeCount > 1 ? 's' : ''}!<br>`;
                    if (allWins.length === 1) {
                        const win = allWins[0];
                        explanation += `${win.consecutiveColumns} consecutive columns with ${win.count} symbols.`;
                    } else {
                        explanation += `Multiple winning combinations created amazing cascades!`;
                    }
                    winExplanation.innerHTML = explanation;
                    
                    // Create payout display
                    winPayoutEl.innerHTML = `
                        🎯 ${totalPercentage.toFixed(3)}% of Prize Pool<br>
                        💰 ${totalPayout.toFixed(0)} coins
                    `;
                    
                    // Create detailed breakdown
                    let breakdownHTML = '<h4>🔍 Win Breakdown</h4>';
                    
                    // Show each cascade
                    let runningTotal = 0;
                                            for (let i = 0; i < cascadeCount; i++) {
                            const cascadeWins = allWins.filter(w => w.cascade === i + 1);
                            if (cascadeWins.length > 0) {
                                let cascadePercentage = 0;
                                for (const win of cascadeWins) {
                                    // Fix the symbol percentage calculation to match actual symbol names
                                    let basePercentage = 0;
                                    const symbolName = win.outcome.toLowerCase();
                                    
                                    if (symbolName === 's') {
                                        basePercentage = 0.001;  // 0.001%
                                    } else if (symbolName === 'o') {
                                        basePercentage = 0.002;  // 0.002%
                                    } else if (symbolName === 'l') {
                                        basePercentage = 0.005;  // 0.005%
                                    } else if (symbolName === 'trump' || symbolName === 'elon') {
                                        basePercentage = 0.5;    // 0.5%
                                    } else if (symbolName === 'dog' || symbolName === 'cat') {
                                        basePercentage = 1.0;    // 1%
                                    } else if (symbolName === 'pepe') {
                                        basePercentage = 100.0;  // 100%
                                    }
                                    
                                    const symbolMultiplier = win.count / 3;
                                    cascadePercentage += basePercentage * symbolMultiplier;
                                }
                                const cascadeMultiplier = 1 + (i) * 0.5;
                                cascadePercentage *= cascadeMultiplier;
                                runningTotal += cascadePercentage;
                                
                                const cascadeWinText = cascadeWins.map(w => w.outcome).join(', ');
                                breakdownHTML += `
                                    <div class="breakdown-item">
                                        <span class="breakdown-label">Cascade ${i + 1}: ${cascadeWinText}</span>
                                        <span class="breakdown-value">${cascadePercentage.toFixed(3)}%</span>
                                    </div>
                                `;
                            }
                        }
                    
                    if (cascadeCount > 1) {
                        breakdownHTML += `
                            <div class="breakdown-item">
                                <span class="breakdown-label">🚀 CASCADE BONUS MULTIPLIER</span>
                                <span class="breakdown-value">+${((cascadeCount - 1) * 50).toFixed(0)}%</span>
                            </div>
                        `;
                    }
                    
                    breakdownHTML += `
                        <div class="breakdown-item">
                            <span class="breakdown-label">💰 TOTAL PAYOUT</span>
                            <span class="breakdown-value">${totalPercentage.toFixed(3)}%</span>
                        </div>
                    `;
                    
                    winBreakdown.innerHTML = breakdownHTML;
                    
                    // Show the popup with animation
                    winPopup.classList.add('show');
                    
                    // Auto-hide after delay (longer for mega wins)
                    setTimeout(() => {
                        hideWinPopup();
                    }, isMegaWin ? 8000 : 6000);
                }
                
                // Function to hide win popup
                function hideWinPopup() {
                    const winPopup = document.getElementById('win-popup');
                    winPopup.classList.remove('show');
                    setTimeout(() => {
                        winPopup.classList.remove('mega-win');
                    }, 400);
                }

                // Function to tweet the win
                function tweetWin() {
                    if (!lastWinData) {
                        console.warn('No win data available for tweeting');
                        return;
                    }

                    const { allWins, totalPayout, totalPercentage, cascadeCount } = lastWinData;
                    
                    // Generate tweet text
                    let tweetText = '';
                    
                    if (cascadeCount >= 3) {
                        tweetText += `🎰 MEGA WIN! Just hit ${cascadeCount} cascades `;
                    } else {
                        tweetText += `🎰 BIG WIN! `;
                    }
                    
                    // Add payout info
                    if (totalPayout >= 1) {
                        tweetText += `and won ${totalPayout.toFixed(2)} SOL `;
                    } else {
                        tweetText += `and won ${totalPayout.toFixed(4)} SOL `;
                    }
                    
                    // Add percentage
                    tweetText += `(${totalPercentage.toFixed(2)}% of the pot) `;
                    
                    // Add symbols if available
                    if (allWins && allWins.length > 0) {
                        const symbols = allWins.map(win => win.outcome).join(', ');
                        tweetText += `with ${symbols}! `;
                    }
                    
                    // Add hashtags and call to action
                    tweetText += `\n\n🚀 Think you can beat this? Try your luck!\n\n#SlotMachine #CryptoCasino #BigWin #SOL #Solana #Gambling #Win`;
                    
                    // Encode the tweet text for URL
                    const encodedText = encodeURIComponent(tweetText);
                    
                    // Create the Twitter intent URL
                    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodedText}`;
                    
                    // Open Twitter in a new window
                    window.open(twitterUrl, '_blank', 'width=550,height=420,scrollbars=yes,resizable=yes');
                    
                    console.log('🐦 Tweet window opened:', tweetText);
                }
                
                                // OLD displayCascadeResults FUNCTION REMOVED
                // Now using horizontal tumble system with real pot-based payouts

    // INITIALIZE: randomize on load with weighted selection
    function initializeSlots() {
        const allSlots = document.querySelectorAll(".reel-wrapper .reel");
        
        // Create weighted symbol selection for initialization - HEAVILY house-favored
        function getWeightedRandomSymbolInit() {
            const weights = {
                "figure-1": 30,  // S - very common (increased)
                "figure-2": 30,  // O - very common (increased)
                "figure-3": 30,  // L - very common (increased)
                "figure-4": 2,   // Trump - ultra rare (was 8)
                "figure-5": 2,   // Elon - ultra rare (was 8)
                "figure-6": 1,   // Dog - legendary rare (was 4)
                "figure-7": 1,   // Popcat - legendary rare (was 4)
                "figure-8": 1    // Pepe - ultra rare (unchanged)
            };
            
            const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
            let random = Math.random() * totalWeight;
            
            for (const [symbol, weight] of Object.entries(weights)) {
                random -= weight;
                if (random <= 0) {
                    return symbol;
                }
            }
            return "figure-1"; // fallback
        }
        
        allSlots.forEach(slot => {
            const groups = slot.querySelectorAll(".icons-group");
            groups.forEach(group => {
                const figs = group.querySelectorAll(".icon");
                figs.forEach(fig => {
                    fig.className = "icon";
                    const randomSymbol = getWeightedRandomSymbolInit();
                    fig.classList.add(randomSymbol);
                });
            });
        });
    }

    document.addEventListener('DOMContentLoaded', initializeSlots);
    initializeSlots();

    // Initialize audio
    document.addEventListener('DOMContentLoaded', function() {
        initializeBackgroundMusic();
        initializeSpinMusic();
        initializeTumbleSound();
    });
    setTimeout(() => {
        initializeBackgroundMusic();
        initializeSpinMusic();
        initializeTumbleSound();
    }, 100);

    // ENTER CASINO FUNCTIONALITY WITH CURTAIN EFFECT
    document.addEventListener('DOMContentLoaded', function() {
        const enterCasinoBtn = document.getElementById('enter-casino-btn');
        const landingScreen = document.getElementById('landing-screen');
        const casinoContent = document.getElementById('casino-content');
        const curtainBody = document.querySelector('.curtainBody');
        const overlay = document.querySelector('.overlay');

        enterCasinoBtn.addEventListener('click', function(e) {
            // Prevent default link behavior
            e.preventDefault();
            
            // Disable button to prevent multiple clicks
            enterCasinoBtn.style.pointerEvents = 'none';
            enterCasinoBtn.style.opacity = '0.6';
            
            // Trigger curtain opening animation
            curtainBody.classList.add('curtainOpened');
            
            // Fade out overlay with button
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 2s ease';
            
            // Wait for curtain animation to complete, then transition to casino
            setTimeout(() => {
                landingScreen.style.animation = 'fadeOut 0.8s ease-out forwards';
                
                setTimeout(() => {
                    landingScreen.style.display = 'none';
                    casinoContent.style.display = 'block';
                    
                    // Initialize slot machine after entering casino
                    initializeSlots();
                    
                    // Start background music
                    initializeBackgroundMusic();
                    initializeSpinMusic();
                    initializeTumbleSound();
                }, 800);
            }, 1500); // Reduced delay for faster transition
        });
    });

    // Fade out animation
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.95); }
        }
    `;
    document.head.appendChild(style);

    // IMAGE LOADING CHECK (optional)
    function checkImageLoading() {
        const symbolImages = {
            'figure-1': 'slot symbols/S_BASE.png',
            'figure-2': 'slot symbols/O_BASE.png', 
            'figure-3': 'slot symbols/L_BASE.png',
            'figure-4': 'slot symbols/trump.png',
            'figure-5': 'slot symbols/elon.png',
            'figure-6': 'slot symbols/dogwifhat.png',
            'figure-7': 'slot symbols/popcat.png',
            'figure-8': 'slot symbols/pepe.png'
        };
        Object.entries(symbolImages).forEach(([className, imagePath]) => {
            const img = new Image();
            img.onload = () => console.log(`✓ ${className} image loaded`);
            img.onerror = () => {
                console.warn(`✗ ${className} image failed: ${imagePath}`);
                const elements = document.querySelectorAll(`.${className}`);
                elements.forEach(el => {
                    if (!el.querySelector('.fallback-text')) {
                        const fallback = document.createElement('div');
                        fallback.className = 'fallback-text';
                        fallback.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;font-weight:bold;font-size:calc(${getComputedStyle(el).width}*0.15);text-shadow:2px 2px 4px rgba(0,0,0,0.8);z-index:2;`;
                        const fallbackTexts = {
                            'figure-1': 'S', 'figure-2': 'O', 'figure-3': 'L',
                            'figure-4': 'TRUMP','figure-5': 'ELON','figure-6': 'DOG','figure-7': 'CAT','figure-8': 'PEPE'
                        };
                        fallback.textContent = fallbackTexts[className] || '?';
                        el.appendChild(fallback);
                        el.style.position = 'relative';
                    }
                });
            };
            img.src = imagePath;
        });
    }
    setTimeout(checkImageLoading, 100);

    // VIDEO BACKGROUND INIT (optional)
    function initializeVideoBackground() {
        const video = document.getElementById('background-video');
        if (video) {
            video.muted = true;
            video.volume = 0;
            const playPromise = video.play();
            if (playPromise !== undefined) {
                playPromise.then(() => console.log('✓ Video playing')).catch(() => {
                    console.warn('Video autoplay failed');
                    document.addEventListener('click', () => video.play().catch(e => console.warn('Video play error:', e)), { once: true });
                });
            }
            video.addEventListener('error', () => console.warn('✗ Video load error'));
            video.addEventListener('canplay', () => console.log('📹 Video can play'));
        }
    }
    document.addEventListener('DOMContentLoaded', initializeVideoBackground);
    setTimeout(initializeVideoBackground, 100);

    // INFO MODAL FUNCTIONALITY
    document.addEventListener('DOMContentLoaded', function() {
        const infoButton = document.getElementById('info-button');
        const infoModal = document.getElementById('info-modal');
        const closeButton = document.getElementById('close-info');

        // Open modal when info button is clicked
        infoButton.addEventListener('click', function() {
            infoModal.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        });

        // Close modal when X button is clicked
        closeButton.addEventListener('click', function() {
            infoModal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        });

        // Close modal when clicking outside the content area
        infoModal.addEventListener('click', function(event) {
            if (event.target === infoModal) {
                infoModal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Restore scrolling
            }
        });

        // Close modal when pressing Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && infoModal.style.display === 'block') {
                infoModal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Restore scrolling
            }
        });
    });

    // ══════════════════════════════════════════════════════════════════════════
    // RESULTS TRACKING & FAQ FUNCTIONALITY
    // ══════════════════════════════════════════════════════════════════════════

    // Results tracking variables
    let gameStats = {
        totalSpins: 0,
        totalWins: 0,
        biggestWin: 0,
        spinHistory: []
    };

    // Load stats from localStorage
    function loadStats() {
        const saved = localStorage.getItem('slotMachineStats');
        if (saved) {
            gameStats = JSON.parse(saved);
            updateStatsDisplay();
            updateHistoryDisplay();
        }
    }

    // Save stats to localStorage
    function saveStats() {
        localStorage.setItem('slotMachineStats', JSON.stringify(gameStats));
    }

    // Update stats display
    function updateStatsDisplay() {
        const totalSpinsEl = document.getElementById('total-spins');
        const totalWinsEl = document.getElementById('total-wins');
        const winRateEl = document.getElementById('win-rate');
        const biggestWinEl = document.getElementById('biggest-win');
        
        if (totalSpinsEl) totalSpinsEl.textContent = gameStats.totalSpins;
        if (totalWinsEl) totalWinsEl.textContent = gameStats.totalWins;
        if (winRateEl) {
            winRateEl.textContent = gameStats.totalSpins > 0 ? 
                Math.round((gameStats.totalWins / gameStats.totalSpins) * 100) + '%' : '0%';
        }
        if (biggestWinEl) biggestWinEl.textContent = gameStats.biggestWin + '%';
    }

    // Add result to history
    function addToHistory(symbols, payout, isWin) {
        const timestamp = new Date().toLocaleTimeString();
        const historyItem = {
            symbols: symbols,
            payout: payout,
            isWin: isWin,
            timestamp: timestamp
        };
        
        // Add to beginning of array, keep only last 10 results
        gameStats.spinHistory.unshift(historyItem);
        if (gameStats.spinHistory.length > 10) {
            gameStats.spinHistory.pop();
        }
        
        updateHistoryDisplay();
        saveStats();
    }

    // Update history display
    function updateHistoryDisplay() {
        const historyList = document.getElementById('spin-history');
        if (!historyList) return;
        
        if (gameStats.spinHistory.length === 0) {
            historyList.innerHTML = '<div class="history-item placeholder"><span>Start spinning to see your results here!</span></div>';
            return;
        }
        
        historyList.innerHTML = gameStats.spinHistory.map(item => {
            const payoutClass = item.payout >= 10 ? 'big' : '';
            const itemClass = item.isWin ? (item.payout >= 10 ? 'big-win' : 'win') : '';
            
            return `
                <div class="history-item ${itemClass}">
                    <div class="history-symbols">${item.symbols}</div>
                    <div class="history-payout ${payoutClass}">
                        ${item.isWin ? '+' + item.payout + '%' : 'No Win'}
                    </div>
                    <div class="history-time">${item.timestamp}</div>
                </div>
            `;
        }).join('');
    }

    // Update stats after each spin
    function updateGameStats(payout, isWin, winSymbols) {
        gameStats.totalSpins++;
        if (isWin) {
            gameStats.totalWins++;
            if (payout > gameStats.biggestWin) {
                gameStats.biggestWin = payout;
            }
        }
        
        // Create symbols string for history
        const symbolsText = winSymbols && winSymbols.length > 0 ? 
            winSymbols.map(w => w.symbol.replace('figure-', '').toUpperCase()).join(', ') : 
            'Mixed';
        
        updateStatsDisplay();
        addToHistory(symbolsText, payout, isWin);
    }

    // FAQ toggle functionality
    function initializeFAQ() {
        const faqItems = document.querySelectorAll('.faq-item');
        
        faqItems.forEach(item => {
            const question = item.querySelector('.faq-question');
            if (question) {
                question.addEventListener('click', () => {
                    const isActive = item.classList.contains('active');
                    
                    // Close all other FAQ items
                    faqItems.forEach(otherItem => {
                        otherItem.classList.remove('active');
                    });
                    
                    // Toggle current item
                    if (!isActive) {
                        item.classList.add('active');
                    }
                });
            }
        });
    }

    // Clear history button
    function initializeClearHistory() {
        const clearBtn = document.getElementById('clear-history');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear your spin history?')) {
                    gameStats.spinHistory = [];
                    gameStats.totalSpins = 0;
                    gameStats.totalWins = 0;
                    gameStats.biggestWin = 0;
                    updateStatsDisplay();
                    updateHistoryDisplay();
                    saveStats();
                }
            });
        }
    }

    // Initialize win popup functionality
    function initializeWinPopup() {
        const winPopup = document.getElementById('win-popup');
        const closeButton = document.getElementById('win-popup-close');
        const overlay = winPopup.querySelector('.win-popup-overlay');
        
        // Close popup when close button is clicked
        closeButton.addEventListener('click', hideWinPopup);
        
        // Close popup when clicking on overlay
        overlay.addEventListener('click', hideWinPopup);
        
        // Close popup when pressing Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && winPopup.classList.contains('show')) {
                hideWinPopup();
            }
        });
    }

    // Synchronize pool displays
    function synchronizePoolDisplays(amount) {
        const topPoolAmount = document.getElementById('top-pool-amount');
        const poolAmount = document.getElementById('pool-amount');
        
        const formattedAmount = amount.toLocaleString();
        
        if (topPoolAmount) topPoolAmount.textContent = formattedAmount;
        if (poolAmount) poolAmount.textContent = formattedAmount;
    }

    // Initialize pool displays on load
    function initializePoolDisplays() {
        // Ensure both displays show the same value
        const initialPool = 300;
        synchronizePoolDisplays(initialPool);
    }

    // Initialize info sections when page loads
    document.addEventListener('DOMContentLoaded', () => {
        loadStats();
        initializeFAQ();
        initializeClearHistory();
        initializeWinPopup();
        initializePoolDisplays();
        initializeDemoWinExpansion();
        
        // Initialize the pot display with current values
        updatePotDisplay();
        console.log("🏦 [Casino] Pot-based casino system initialized with", totalSolPot, "SOL");
    });

    // Initialize expansion functionality using event delegation
    function initializeDemoWinExpansion() {
        const winsStream = document.getElementById('wins-stream');
        if (!winsStream) {
            console.warn('⚠️ wins-stream element not found!');
            return;
        }
        
        // Use event delegation - listen on the parent container
        winsStream.addEventListener('click', function(e) {
            // Find the closest win-entry element
            const winEntry = e.target.closest('.win-entry');
            if (!winEntry) {
                console.log('🔍 No win-entry found for click target:', e.target);
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            console.log('🎯 Clicked on win entry:', winEntry);
            
            // Close other expanded entries first
            const otherExpanded = winsStream.querySelectorAll('.win-entry.expanded');
            otherExpanded.forEach(other => {
                if (other !== winEntry) {
                    other.classList.remove('expanded');
                    console.log('📖 Closed other expanded entry');
                }
            });
            
            // Toggle expanded state on clicked entry
            const wasExpanded = winEntry.classList.contains('expanded');
            winEntry.classList.toggle('expanded');
            
            console.log(`🎉 Entry ${wasExpanded ? 'collapsed' : 'expanded'}:`, winEntry);
            
            // Force a small reflow to ensure CSS transitions work properly
            winEntry.offsetHeight;
        });
        
        console.log('✅ Live wins expansion event delegation initialized');
    }

    // Stats are now updated directly from the horizontal tumble system
    // No need for cascade hooks - wins are tracked in real-time

    // ───────────────────────────────────────────────────────────────────────────
    // Define the total pot in SOL and fetch SOL→USD price
    // ───────────────────────────────────────────────────────────────────────────
    const totalPotSol = 300;   // Prize pool is 300 SOL total
    
    // ──────────────────────────────────────────────────────────────────────────
    // SOL TO USD CONVERSION - Real-time price fetching
    // ──────────────────────────────────────────────────────────────────────────
    
    let solPriceUSD = 150; // Default fallback price
    
    async function fetchSOLPrice() {
        try {
            const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
            const data = await response.json();
            if (data && data.solana && data.solana.usd) {
                solPriceUSD = data.solana.usd;
                updatePrizePoolUSD();
                console.log('✓ SOL Price updated:', solPriceUSD);
            }
        } catch (error) {
            console.warn('Failed to fetch SOL price, using fallback:', error);
            // Keep using the fallback price
        }
    }
    
    function updatePrizePoolUSD() {
        const prizePoolUSDElement = document.getElementById('top-pool-usd');
        if (prizePoolUSDElement) {
            const usdValue = (totalPotSol * solPriceUSD).toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            });
            prizePoolUSDElement.textContent = usdValue;
        }
    }
    
    // Initialize price on page load
    fetchSOLPrice();
    
    // Update price every 5 minutes
    setInterval(fetchSOLPrice, 5 * 60 * 1000);
    
    // ──────────────────────────────────────────────────────────────────────────
    // ENHANCED AUDIO CONTROLS - Volume Sliders
    // ──────────────────────────────────────────────────────────────────────────
    
    // Audio references
    const musicVolumeSlider = document.getElementById('music-volume-slider');
    const soundVolumeSlider = document.getElementById('sound-volume-slider');
    const musicMuteBtn = document.getElementById('music-mute-btn');
    const soundMuteBtn = document.getElementById('sound-mute-btn');
    
    // Volume state management
    let musicMuted = false;
    let soundMuted = false;
    let lastMusicVolume = 30;
    let lastSoundVolume = 50;
    
    // Set initial volumes
    backgroundMusic.volume = musicVolumeSlider.value / 100;
    
    // Music volume slider handler
    musicVolumeSlider.addEventListener('input', function() {
        const volume = this.value / 100;
        backgroundMusic.volume = volume;
        spinBuildupMusic.volume = volume * 2; // Slightly louder for buildup
        
        // Update mute state
        if (volume === 0) {
            musicMuted = true;
            musicMuteBtn.classList.add('muted');
        } else {
            musicMuted = false;
            musicMuteBtn.classList.remove('muted');
            lastMusicVolume = this.value;
        }
    });
    
    // Sound effects volume slider handler
    soundVolumeSlider.addEventListener('input', function() {
        const volume = this.value / 100;
        winSound.volume = volume;
        explosionSound.volume = volume * 0.6; // Slightly quieter for explosions
        tumbleSound.volume = volume * 0.8;
        countdownSound.volume = volume;
        
        // Update mute state
        if (volume === 0) {
            soundMuted = true;
            soundMuteBtn.classList.add('muted');
        } else {
            soundMuted = false;
            soundMuteBtn.classList.remove('muted');
            lastSoundVolume = this.value;
        }
    });
    
    // Music mute button handler
    musicMuteBtn.addEventListener('click', function() {
        if (musicMuted) {
            // Unmute
            musicMuted = false;
            musicVolumeSlider.value = lastMusicVolume;
            backgroundMusic.volume = lastMusicVolume / 100;
            spinBuildupMusic.volume = (lastMusicVolume / 100) * 2;
            this.classList.remove('muted');
        } else {
            // Mute
            musicMuted = true;
            lastMusicVolume = musicVolumeSlider.value;
            musicVolumeSlider.value = 0;
            backgroundMusic.volume = 0;
            spinBuildupMusic.volume = 0;
            this.classList.add('muted');
        }
    });
    
    // Sound effects mute button handler
    soundMuteBtn.addEventListener('click', function() {
        if (soundMuted) {
            // Unmute
            soundMuted = false;
            soundVolumeSlider.value = lastSoundVolume;
            const volume = lastSoundVolume / 100;
            winSound.volume = volume;
            explosionSound.volume = volume * 0.6;
            tumbleSound.volume = volume * 0.8;
            countdownSound.volume = volume;
            this.classList.remove('muted');
        } else {
            // Mute
            soundMuted = true;
            lastSoundVolume = soundVolumeSlider.value;
            soundVolumeSlider.value = 0;
            winSound.volume = 0;
            explosionSound.volume = 0;
            tumbleSound.volume = 0;
            countdownSound.volume = 0;
            this.classList.add('muted');
        }
    });
    
    // Enhanced audio mute state function
    function ensureAudioMuteState(audio, isMusicTrack) {
        if (isMusicTrack && musicMuted) {
            audio.volume = 0;
        } else if (!isMusicTrack && soundMuted) {
            audio.volume = 0;
        }
    }
    
    let currentSolPriceUsd = null;

    // ───────────────────────────────────────────────────
    // RUNNING TOTALS (for Auto-Spin accumulation)
    let runningSolTotal = 0;
    let runningUsdTotal = 0;

                        // ───────────────────────────────────────────────────
                    // MULTIPLAYER LIVE TRACKING VARIABLES
                    let liveWinsHistory = [];
                    let livePayoutsHistory = [];

    async function fetchSolPrice() {
        try {
            const resp = await fetch(
                'https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd'
            );
            const data = await resp.json();
            if (data.solana && data.solana.usd) {
                currentSolPriceUsd = data.solana.usd;
                console.log('SOL price = $' + currentSolPriceUsd.toFixed(2));
            }
        } catch (err) {
            console.error('Could not fetch SOL price:', err);
        }
    }

    // Fetch price on load and every minute
    fetchSolPrice();
    setInterval(fetchSolPrice, 60 * 1000);

    // ───────────────────────────────────────────────────────────────────────────
    // AUDIO CONTROL FUNCTIONALITY
    // ───────────────────────────────────────────────────────────────────────────
    
    // Track mute states
    let isMusicMuted = false;
    let isSoundMuted = false;
    
    // Get all audio elements - moved inside a function to ensure proper timing
    function getAllAudioElements() {
        const autoMusic = document.getElementById('auto-spin-music');
        
        const musicElements = [backgroundMusic, spinBuildupMusic, autoMusic].filter(Boolean);
        const soundElements = [tumbleSound, countdownSound, winSound, explosionSound].filter(Boolean);
        
        return { musicElements, soundElements };
    }
    
    // Load saved mute states from localStorage
    function loadAudioSettings() {
        const savedMusicMute = localStorage.getItem('musicMuted');
        const savedSoundMute = localStorage.getItem('soundMuted');
        
        if (savedMusicMute === 'true') {
            isMusicMuted = true;
            applyMusicMute();
            updateMusicButton();
        }
        if (savedSoundMute === 'true') {
            isSoundMuted = true;
            applySoundMute();
            updateSoundButton();
        }
    }
    
    // Save mute states to localStorage
    function saveAudioSettings() {
        localStorage.setItem('musicMuted', isMusicMuted.toString());
        localStorage.setItem('soundMuted', isSoundMuted.toString());
    }
    
    // Apply music mute state to all music elements
    function applyMusicMute() {
        const { musicElements } = getAllAudioElements();
        musicElements.forEach(audio => {
            if (audio) {
                audio.muted = isMusicMuted;
            }
        });
    }
    
    // Apply sound mute state to all sound elements
    function applySoundMute() {
        const { soundElements } = getAllAudioElements();
        soundElements.forEach(audio => {
            if (audio) {
                audio.muted = isSoundMuted;
            }
        });
    }
    
    // Update music button appearance
    function updateMusicButton() {
        const musicBtn = document.getElementById('music-mute-btn');
        if (!musicBtn) return;
        
        if (isMusicMuted) {
            musicBtn.classList.add('muted');
            musicBtn.title = 'Unmute Music';
        } else {
            musicBtn.classList.remove('muted');
            musicBtn.title = 'Mute Music';
        }
    }
    
    // Update sound button appearance
    function updateSoundButton() {
        const soundBtn = document.getElementById('sound-mute-btn');
        if (!soundBtn) return;
        
        if (isSoundMuted) {
            soundBtn.classList.add('muted');
            soundBtn.title = 'Unmute Sound Effects';
            const iconEl = soundBtn.querySelector('.audio-icon');
            if (iconEl) iconEl.textContent = '🔇';
        } else {
            soundBtn.classList.remove('muted');
            soundBtn.title = 'Mute Sound Effects';
            const iconEl = soundBtn.querySelector('.audio-icon');
            if (iconEl) iconEl.textContent = '🔊';
        }
    }
    
    // Toggle music mute
    function toggleMusic() {
        isMusicMuted = !isMusicMuted;
        applyMusicMute();
        updateMusicButton();
        saveAudioSettings();
        console.log(isMusicMuted ? '🔇 Music muted' : '🎵 Music unmuted');
    }
    
    // Toggle sound effects mute
    function toggleSound() {
        isSoundMuted = !isSoundMuted;
        applySoundMute();
        updateSoundButton();
        saveAudioSettings();
        console.log(isSoundMuted ? '🔇 Sound effects muted' : '🔊 Sound effects unmuted');
    }
    
    // Ensure audio respects mute state when playing
    function ensureAudioMuteState(audioElement, isMusic = false) {
        if (audioElement) {
            audioElement.muted = isMusic ? isMusicMuted : isSoundMuted;
        }
    }
    
    // Add event listeners for the mute buttons
    document.addEventListener('DOMContentLoaded', function() {
        const musicBtn = document.getElementById('music-mute-btn');
        const soundBtn = document.getElementById('sound-mute-btn');
        
        if (musicBtn) {
            musicBtn.addEventListener('click', toggleMusic);
        }
        
        if (soundBtn) {
            soundBtn.addEventListener('click', toggleSound);
        }
        
        // Load saved audio settings after a short delay to ensure all audio elements are ready
        setTimeout(() => {
            loadAudioSettings();
            // Force apply mute state to all audio elements
            applyMusicMute();
            applySoundMute();
        }, 500);
    });

                    // ───────────────────────────────────────────────────────────────────────────
                    // LIVE WINS & PAYOUTS TRACKING FUNCTIONALITY
                    // ───────────────────────────────────────────────────────────────────────────
                    
                    // Generate random wallet address for demo
                    function generateRandomWallet() {
                        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789';
                        let result = '';
                        for (let i = 0; i < 8; i++) {
                            result += chars.charAt(Math.floor(Math.random() * chars.length));
                        }
                        return result + '...';
                    }
                    
                    // Add live win entry (ONLY REAL WINS FROM CONNECTED WALLETS)
                    function addLiveWin(solAmount, usdAmount, isWin, winType = "Real Win") {
                        // ✅ ONLY PROCESS REAL WINS - No fake losses or random wallets
                        if (!isWin || !isWalletConnected || !userPublicKey) {
                            console.log("🚫 Ignoring non-win or non-authenticated win attempt");
                            return;
                        }
                        
                        // ✅ USE REAL CONNECTED WALLET ADDRESS - No more fake addresses
                        const realWalletAddress = userPublicKey;
                        
                        // Only show real wins from real wallets
                        addCryptoWinToFeed(realWalletAddress, solAmount, usdAmount, winType);
                            
                        // Log real win for verification
                        console.log(`✅ REAL WIN: ${realWalletAddress.slice(0,8)}... won ${solAmount} SOL`);
                        }
                    

                    
                    // Add live payout entry (safely disabled - using live wins panel instead)
                    function addLivePayout(winSol, isWin) {
                        // This function is completely disabled since we're using the live wins panel instead
                        // Added comprehensive safety checks to prevent any errors
                        try {
                            if (!winSol || !isWin) return;
                            
                            // The live wins panel already shows all win information beautifully
                            // No need to add to a separate payout feed
                            console.log('💰 Payout logged:', winSol, 'SOL - (handled by live wins panel)');
                            return;
                        } catch (error) {
                            console.warn('⚠️ addLivePayout error caught and handled:', error);
                            return;
                        }
                    }
                    
                        // Horizontal tumble system handles live wins directly
    // No need for cascade result hooks - payouts are processed in real-time
                    
                    // ✅ FAKE WIN GENERATION REMOVED
                    // Only real spins from actual players will generate wins now
                    
                    // function simulateOtherPlayers() { /* REMOVED - was generating fake wins */ }
                    // setInterval(simulateOtherPlayers, 3000 + Math.random() * 5000); /* REMOVED */

                    // ───────────────────────────────────────────────────────────────────────────
                    // RIGGED SPIN HELPERS (admin-controlled one-time rig entries)
                    // ───────────────────────────────────────────────────────────────────────────
                    /**
                     * Fetch a rig entry for the given wallet and delete it (one-time use).
                     * Returns the percentage (number) or null if none found.
                     */
                    async function getAndClearRig(walletAddress) {
                        try {
                            const docRef = db.collection("riggedSpins").doc(walletAddress);
                            const snap = await docRef.get();
                            if (!snap.exists) return null;

                            const { nextWinPercent } = snap.data() || {};
                            // Delete so it only triggers once
                            await docRef.delete();
                            return typeof nextWinPercent === "number" ? nextWinPercent : null;
                        } catch (err) {
                            console.warn("⚠️ [Rig] Error retrieving rig entry:", err);
                            return null;
                        }
                    }

                    /**
                     * Execute a rigged spin that pays exactly the requested percentage of the pot.
                     * Handles pot deduction, player payout, live-wins feed, and UI feedback.
                     */
                    async function runRiggedSpin(percent) {
                        try {
                            // Safety clamp
                            percent = Math.max(0.01, Math.min(percent, 100));

                            const fraction = percent / 100;
                            const payoutSol = totalSolPot * fraction;
                            if (payoutSol <= 0) return;

                            console.log(`🥷 [Rig] Paying ${percent}% of pot → ${payoutSol.toFixed(6)} SOL`);

                            // Deduct from pot first (animateSlotSpin normally does this internally)
                            totalSolPot -= payoutSol;
                            updatePotDisplay();

                            // Pay player using existing routine (updates counters, live feed, etc.)
                            await payOutToPlayer(payoutSol);

                            // Simple result display
                            const resultEl = document.getElementById("result");
                            if (resultEl) {
                                resultEl.innerHTML = `🎯 RIGGED WIN! +${payoutSol.toFixed(6)} SOL (${percent}% of pot)`;
                                resultEl.className = "result-display win mega-win";
                            }

                            // Optional: brief visual fake spin (can be expanded later)
                            await sleep(500); // placeholder animation delay

                        } catch (err) {
                            console.error("❌ [Rig] runRiggedSpin failed:", err);
                        }
                    }

                    </script>

    <!-- ─── NOTIFICATION SYSTEM ─── -->
    <script>
        // ──────────────────────────────────────────────────────────────────────────
        // NOTIFICATION SYSTEM
        // ──────────────────────────────────────────────────────────────────────────
        
        function showNotification(title, message, icon = '🎰', type = 'normal') {
            const overlay = document.getElementById('notification-overlay');
            if (!overlay) {
                console.error('Notification overlay not found!');
                return;
            }
            
            const box = overlay.querySelector('.notification-box');
            const titleEl = document.getElementById('notification-title');
            const messageEl = document.getElementById('notification-message');
            const iconEl = overlay.querySelector('.notification-icon');
            const closeBtn = document.getElementById('notification-close');
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            iconEl.textContent = icon;
            
            // Apply styling based on type
            box.classList.remove('warning', 'success');
            if (type === 'warning') {
                box.classList.add('warning');
            } else if (type === 'success') {
                box.classList.add('success');
            }
            
            // Force reflow and show notification
            overlay.style.display = 'flex';
            overlay.offsetHeight; // Force reflow
            overlay.classList.add('show');
            
            // Ensure it's on top of everything
            overlay.style.zIndex = '999999';
            
            // Close button functionality
            const closeNotification = () => {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 300);
                closeBtn.removeEventListener('click', closeNotification);
            };
            
            closeBtn.addEventListener('click', closeNotification);
            
            // Auto-close after 8 seconds
            setTimeout(() => {
                if (overlay.classList.contains('show')) {
                    closeNotification();
                }
            }, 8000);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeNotification();
                }
            });
        }
        
        // Function to show "no spins" notification
        function showNoSpinsNotification() {
            showNotification(
                'No Spins Available!',
                'You need more tokens to play. You get 1 spin per 100,000 tokens held.',
                '🪙',
                'warning'
            );
        }
        
        // Function to show wallet connected notification
        function showWalletConnectedNotification(spins, tokens = 0) {
            let message;
            if (spins > 0) {
                message = `Wallet connected! You have ${tokens.toLocaleString()} tokens and ${spins} spin${spins === 1 ? '' : 's'} available.`;
            } else {
                message = `Wallet connected! You have ${tokens.toLocaleString()} tokens. Need 100,000+ tokens to spin.`;
            }
                
            showNotification(
                'Wallet Connected!',
                message,
                '✅',
                'success'
            );
        }
        
        // Test functions - you can call these from console to test notifications
        window.testNotification = function() {
            showNotification(
                'Test Notification',
                'This is a test of the new notification system! No more browser popups.',
                '🧪',
                'normal'
            );
        };
        
        window.testWarning = function() {
            showNotification(
                'Warning Test',
                'This is a warning notification with beautiful red gradient background!',
                '⚠️',
                'warning'
            );
        };
        
        window.testSuccess = function() {
            showNotification(
                'Success Test',
                'This is a success notification with beautiful green gradient background!',
                '✅',
                'success'
            );
        };
        
        window.testNoSpins = function() {
            showNoSpinsNotification();
        };
    </script>

    <!-- ─── CRYPTO CASINO INTEGRATION ─── -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

    <script>
        // ──────────────────────────────────────────────────────────────────────────
        // CRYPTO CASINO INTEGRATION
        // ──────────────────────────────────────────────────────────────────────────
        
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBj2IiblX0ZfhUxwJcTXmZ5A0aYVKDfGs4",
            authDomain: "memebonanza-8c0f7.firebaseapp.com",
            projectId: "memebonanza-8c0f7",
            storageBucket: "memebonanza-8c0f7.firebasestorage.app",
            messagingSenderId: "1054230604841",
            appId: "1:1054230604841:web:716da4032ce24324078038",
            measurementId: "G-TLFH3YBPNF"
        };
        
        // Initialize Firebase
        let db = null;
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            console.log("🔥 Firebase initialized successfully");
        } catch (error) {
            console.warn("⚠️ Firebase initialization failed - using demo mode", error);
        }

        // ──────────────────────────────────────────────────────────────────────────
        // CRYPTO CASINO STATE
        // ──────────────────────────────────────────────────────────────────────────
        let userPublicKey = null;
        let availableSpins = 0;
        let tokenMintAddress = null;
        let isWalletConnected = false;

        // UI Elements with existence validation
        const connectWalletBtn = document.getElementById('connect-wallet-btn');
        const walletInfo = document.getElementById('wallet-info');
        const walletAddressSpan = document.getElementById('wallet-address');
        const availableSpinsSpan = document.getElementById('available-spins');
        const cryptoWinsFeed = document.getElementById('crypto-wins-feed');

        // Log warnings for missing crypto integration elements
        if (!connectWalletBtn) console.warn("⚠️ [Crypto] #connect-wallet-btn not found - wallet functionality disabled");
        if (!walletInfo) console.warn("⚠️ [Crypto] #wallet-info not found - wallet display disabled");
        if (!walletAddressSpan) console.warn("⚠️ [Crypto] #wallet-address not found - address display disabled");
        if (!availableSpinsSpan) console.warn("⚠️ [Crypto] #available-spins not found - spin counter disabled");
        if (!cryptoWinsFeed) console.warn("⚠️ [Crypto] #crypto-wins-feed not found - using live wins panel instead");

        // ──────────────────────────────────────────────────────────────────────────
        // FIREBASE FUNCTIONS
        // ──────────────────────────────────────────────────────────────────────────

        // Get token configuration from Firebase
        async function getTokenConfig() {
            if (!db) {
                // Demo mode - use a placeholder token address
                tokenMintAddress = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // USDC for demo
                return;
            }

            try {
                const settingsDoc = await db.collection("settings").doc("tokenConfig").get();
                if (settingsDoc.exists) {
                    tokenMintAddress = settingsDoc.data().mintAddress;
                    console.log("📋 Token mint address loaded:", tokenMintAddress);
                } else {
                    console.warn("⚠️ Token config not found in Firebase");
                }
            } catch (error) {
                console.error("❌ Error fetching token config:", error);
            }
        }

        // Record a win to Firebase
        async function recordWin(amount, winType) {
            if (!db || !userPublicKey) return;

            try {
                await db.collection("wins").add({
                    address: userPublicKey,
                    amount: amount,
                    winType: winType,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log("🎉 Win recorded to Firebase:", { amount, winType });
            } catch (error) {
                console.error("❌ Error recording win:", error);
            }
        }

        // Listen for live wins
        function setupLiveWinsListener() {
            if (!db) {
                // ✅ NO MORE DEMO WINS - only show real wins from Firebase
                console.log("🔥 Firebase not available - only real spins will show wins");
                return;
            }

            // Check if cryptoWinsFeed exists, if not, just log warning
            if (!cryptoWinsFeed) {
                console.warn("⚠️ crypto-wins-feed element not found - using live wins panel instead");
                return;
            }

            db.collection("wins")
                .orderBy("timestamp", "desc")
                .limit(10)
                .onSnapshot((snapshot) => {
                    if (cryptoWinsFeed) {
                        cryptoWinsFeed.innerHTML = "";
                        
                        if (snapshot.empty) {
                            cryptoWinsFeed.innerHTML = '<div class="crypto-win-item placeholder"><span class="win-wallet">No wins yet...</span></div>';
                            return;
                        }
                    }

                    snapshot.forEach((doc) => {
                        const { address, amount, winType } = doc.data();
                        addCryptoWinToFeed(address, amount, winType);
                    });
                }, (error) => {
                    console.error("❌ Error listening to wins:", error);
                    // ✅ NO MORE DEMO WINS - just log the error
                });
        }

                            // Add crypto win to feed (updated for new live wins panel)
                    function addCryptoWinToFeed(address, solAmount, usdAmount, winType = "Standard Win") {
                        const winsStream = document.getElementById('wins-stream');
                        if (!winsStream) return;
                        
                        // Remove demo wins if they exist
                        const demoWins = winsStream.querySelectorAll('.demo-win');
                        demoWins.forEach(demo => demo.remove());
                        
            const shortAddress = address.slice(0, 4) + "..." + address.slice(-4);
                        
                        // Determine win type and icon
                        let avatarIcon = '🎯';
                        let winClass = '';
                        let winTypeText = winType;
                        
                        if (parseFloat(solAmount) >= 5) {
                            avatarIcon = '🔥';
                            winClass = 'mega';
                            winTypeText = 'JACKPOT • Legendary!';
                        } else if (parseFloat(solAmount) >= 1) {
                            avatarIcon = '⚡';
                            winTypeText = 'Big Win • Rare Symbol!';
                        } else if (parseFloat(solAmount) >= 0.1) {
                            avatarIcon = '💎';
                            winTypeText = 'Nice Win • Multiple Match!';
                        }
            
            const winItem = document.createElement('div');
                        winItem.className = `win-entry new-win ${winClass}`;
                        
                        // Generate timestamp and full address for expanded view
                        const timestamp = new Date().toLocaleTimeString();
                        const fullAddress = address.length > 15 ? address : address + "...extended_address_example";
                        const multiplier = Math.floor(Math.random() * 5) + 1; // Random multiplier for demo
                        const symbols = ['🎯', '💎', '⚡'].join(' ');
                        
            winItem.innerHTML = `
                            <div class="win-main-row">
                                <div class="win-avatar">
                                    <div class="avatar-ring"></div>
                                    <div class="avatar-icon">${avatarIcon}</div>
                                </div>
                                <div class="win-details">
                                    <div class="win-player">${shortAddress}</div>
                                    <div class="win-amount">
                                        <span class="sol-amount">+${parseFloat(solAmount).toFixed(3)} SOL</span>
                                        <span class="usd-amount">≈ $${parseFloat(usdAmount).toFixed(2)}</span>
                                    </div>
                                    <div class="win-type">${winTypeText}</div>
                                </div>
                                <div class="win-glow"></div>
                            </div>
                            <div class="expand-indicator">▼</div>
                            <div class="win-expanded-details">
                                <div class="expanded-row">
                                    <span class="expanded-label">Full Address:</span>
                                    <span class="expanded-value expanded-wallet">${fullAddress}</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Timestamp:</span>
                                    <span class="expanded-value expanded-timestamp">${timestamp}</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Win Symbols:</span>
                                    <span class="expanded-value">${symbols}</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Multiplier:</span>
                                    <span class="expanded-value">${multiplier}x</span>
                                </div>
                                <div class="expanded-row">
                                    <span class="expanded-label">Base Amount:</span>
                                    <span class="expanded-value">${(parseFloat(solAmount) / multiplier).toFixed(3)} SOL</span>
                                </div>
                            </div>
                        `;
                        
                                                    // Note: Click handler is now handled by event delegation in wins-stream
                        
                        winsStream.insertBefore(winItem, winsStream.firstChild);
                        
                        // Keep only last 15 wins
                        const allWins = winsStream.querySelectorAll('.win-entry:not(.demo-win)');
                        if (allWins.length > 15) {
                allWins[allWins.length - 1].remove();
            }
                        
                        // Update total wins counter
                        const counterValue = document.getElementById('total-wins-counter');
                        if (counterValue) {
                            const currentCount = parseInt(counterValue.textContent.replace(/,/g, ''));
                            const newCount = currentCount + 1;
                            counterValue.textContent = newCount.toLocaleString();
                            counterValue.classList.add('updated');
                            setTimeout(() => {
                                counterValue.classList.remove('updated');
                            }, 600);
                        }
            
            // Remove animation class after animation
            setTimeout(() => {
                            winItem.classList.remove('new-win');
                        }, 1000);
        }

        // Show demo wins for testing
        function showDemoWins() {
                            const winsStream = document.getElementById('wins-stream');
                            if (!winsStream) return;
                            
                            // Clear existing demo wins but keep the template ones in HTML
                            const existingWins = winsStream.querySelectorAll('.win-entry:not(.demo-win)');
                            existingWins.forEach(win => win.remove());
                            
                            // Add some dynamic demo wins
            const demoWins = [
                                { address: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU", solAmount: "0.456", usdAmount: "68.40", winType: "Triple Match" },
                                { address: "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM", solAmount: "1.234", usdAmount: "185.10", winType: "Rare Symbol" },
                                { address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL", solAmount: "2.789", usdAmount: "418.35", winType: "Big Win" },
                                { address: "TokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8", solAmount: "0.089", usdAmount: "13.35", winType: "Small Win" }
                            ];

            demoWins.forEach(win => {
                                addCryptoWinToFeed(win.address, win.solAmount, win.usdAmount, win.winType);
            });
        }

        // ──────────────────────────────────────────────────────────────────────────
        // SECURE WALLET AUTHENTICATION FUNCTIONS
        // ──────────────────────────────────────────────────────────────────────────

        // API Base URL
        // API Base URL - automatically detects environment
        const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const API_BASE = isDevelopment ? 'http://localhost:3001' : '';

        // Get Phantom provider reference
        const provider = window.solana;

        // Step 1: Connect to authorize wallet (called once)
        async function authorizeWallet() {
            if (!provider || !provider.isPhantom) {
                throw new Error("Please install Phantom wallet!");
            }
            
            try {
                // This will pop up Phantom's "Connect" authorization once
                const response = await provider.connect();
                console.log('✅ Wallet authorized:', response.publicKey.toString());
                return response.publicKey.toString();
            } catch (err) {
                console.error('❌ Wallet authorization failed:', err);
                throw err;
            }
        }

        // Step 2: Sign message (after wallet is authorized) 
        async function signAuthenticationMessage(message) {
            if (!provider || !provider.isPhantom) {
                throw new Error("Phantom wallet not found");
            }

            try {
                // Phantom is already authorized, so this only triggers the signature prompt
                const encoded = new TextEncoder().encode(message);
                const { signature } = await provider.signMessage(encoded, 'utf8');
                
                // Convert signature to hex format
                const sigBytes = new Uint8Array(signature);
                const signatureHex = 'hex:' + Array.from(sigBytes)
                    .map(b => b.toString(16).padStart(2, '0')).join('');
                
                return { signature: signatureHex, publicKey: provider.publicKey.toString() };
            } catch (err) {
                console.error('❌ Message signing failed:', err);
                throw err;
            }
        }

        // Connect Wallet using proper two-step authentication flow
        async function connectWallet() {
            try {
                console.log("🔐 Starting wallet authentication...");
                
                // Step 1: Authorize wallet (connect to site)
                console.log("🔗 Requesting wallet authorization...");
                const publicKey = await authorizeWallet();
                console.log("✅ Wallet authorized:", publicKey);
                
                // Step 2: Get nonce from API
                const nonceResponse = await fetch(`${API_BASE}/api/nonce`, {
                    credentials: 'include'
                });
                if (!nonceResponse.ok) throw new Error('Failed to get nonce');
                
                const { nonce, key } = await nonceResponse.json();
                console.log("✅ Nonce received:", nonce.slice(0, 50) + '...');
                
                // Step 3: Sign authentication message (Phantom already authorized, just signature prompt)
                console.log("✉️ Requesting signature for message:", nonce.slice(0, 30) + '...');
                const { signature } = await signAuthenticationMessage(nonce);
                console.log("✅ Message signed by wallet");
                
                console.log("📤 Sending verification request...");
                
                // Step 4: Verify signature with API  
                const verifyResponse = await fetch(`${API_BASE}/api/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        publicKey: publicKey,
                        signature: signature,
                        nonce: nonce,
                        key: key
                    })
                });
                
                if (!verifyResponse.ok) {
                    const error = await verifyResponse.json().catch(() => ({}));
                    throw new Error(error.error || `Authentication failed (${verifyResponse.status})`);
                }
                
                const verifyResult = await verifyResponse.json();
                userPublicKey = verifyResult.publicKey;
                isWalletConnected = true;
                
                console.log("🎯 Wallet authenticated successfully!");
                
                // Update UI and fetch balance
                updateWalletUI();
                await updateTokenBalance();
                
                // Start refresh timer
                startRefreshTimer();
                
                // Show success notification
                showWalletConnectedNotification(availableSpins, 0);
                return publicKey;
                
            } catch (error) {
                console.error("❌ Wallet authentication failed:", error);
                
                // Handle different error types with user-friendly messages
                if (error.message.includes("User rejected") || error.message.includes("declined")) {
                    showNotification(
                        'Connection Declined',
                        'You need to approve the wallet connection and authentication message to play.',
                        '⚠️',
                        'warning'
                    );
                } else if (error.message.includes("Please install Phantom")) {
                    showNotification(
                        'Phantom Wallet Required!',
                        'Please install the Phantom wallet extension to authenticate and play.',
                        '👻',
                        'warning'
                    );
                } else if (error.message.includes("not authorized")) {
                    showNotification(
                        'Authorization Required',
                        'Please approve the site authorization and message signature to continue.',
                        '🔒',
                        'warning'
                    );
                } else {
                    showNotification(
                        'Authentication Failed!',
                        error.message || 'Failed to authenticate wallet. Please try again.',
                        '❌',
                        'warning'
                    );
                }
                return null;
            }
        }

        // Update wallet UI with safe element access
        function updateWalletUI() {
            if (isWalletConnected) {
                const shortAddress = userPublicKey.slice(0, 6) + "..." + userPublicKey.slice(-4);
                if (walletAddressSpan) walletAddressSpan.textContent = shortAddress;
                if (walletInfo) walletInfo.style.display = "block";
                if (connectWalletBtn) {
                    connectWalletBtn.innerHTML = '<span class="wallet-icon">✅</span><span class="wallet-text">Connected</span>';
                    connectWalletBtn.disabled = true;
                }
            }
        }

        // Get token balance and spin data via secure API
        async function updateTokenBalance() {
            if (!isWalletConnected) {
                console.warn("⚠️ Cannot update balance - wallet not authenticated");
                return;
            }

            try {
                console.log("💰 Fetching balance and spin data from secure API...");
                
                // Get both balance and spin data
                const [balanceResponse, spinResponse] = await Promise.all([
                    fetch(`${API_BASE}/api/balance`, { credentials: 'include' }),
                    fetch(`${API_BASE}/api/spins`, { credentials: 'include' })
                ]);
                
                if (!balanceResponse.ok || !spinResponse.ok) {
                    if (balanceResponse.status === 401 || spinResponse.status === 401) {
                        // Session expired, clear wallet state
                        await disconnectWallet();
                        throw new Error('Session expired - please reconnect wallet');
                    }
                    throw new Error('Failed to fetch balance or spin data');
                }
                
                const balanceData = await balanceResponse.json();
                const spinData = await spinResponse.json();
                console.log("✅ Balance and spin data received:", { balanceData, spinData });
                
                // Find the configured token in the balance data
                let totalBalance = 0;
                if (tokenMintAddress && balanceData.tokens) {
                    const targetToken = balanceData.tokens.find(token => token.mint === tokenMintAddress);
                    if (targetToken) {
                        totalBalance = targetToken.amount || 0;
                    }
                }
                
                // Update SOL balance display if available
                const solBalanceSpan = document.getElementById('sol-balance');
                if (solBalanceSpan && balanceData.sol !== undefined) {
                    solBalanceSpan.textContent = balanceData.sol.toFixed(6);
                }
                
                // Update token balance display
                const tokenBalanceSpan = document.getElementById('token-balance');
                if (tokenBalanceSpan) {
                    tokenBalanceSpan.textContent = totalBalance.toLocaleString();
                }

                // Update spin data from API
                availableSpins = spinData.availableSpins || 0;
                if (availableSpinsSpan) availableSpinsSpan.textContent = availableSpins;

                // Update total earnings display
                const totalEarningsSpan = document.getElementById('total-earnings');
                if (totalEarningsSpan) {
                    totalEarningsSpan.textContent = (spinData.totalEarnings || 0).toFixed(6);
                }

                // Update refresh timer display
                const refreshTimerSpan = document.getElementById('refresh-timer');
                if (refreshTimerSpan) {
                    const hoursUntilRefresh = spinData.hoursUntilRefresh || 0;
                    if (hoursUntilRefresh > 0) {
                        const hours = Math.floor(hoursUntilRefresh);
                        const minutes = Math.floor((hoursUntilRefresh - hours) * 60);
                        refreshTimerSpan.textContent = `${hours}h ${minutes}m`;
                    } else {
                        refreshTimerSpan.textContent = "Ready!";
                    }
                }
                
                console.log(`💰 SOL: ${balanceData.sol?.toFixed(6)}, Tokens: ${totalBalance.toLocaleString()}, Spins: ${availableSpins}, Earnings: ${spinData.totalEarnings?.toFixed(6)}`);

            } catch (error) {
                console.error("❌ Error fetching balance:", error);
                
                // Show error notification for session expiry
                if (error.message.includes('Session expired')) {
                    showNotification(
                        'Session Expired!',
                        'Your wallet session has expired. Please reconnect to continue playing.',
                        '⏰',
                        'warning'
                    );
                    return;
                }
                
                // For other errors, show demo values temporarily
                const tokenBalanceSpan = document.getElementById('token-balance');
                if (tokenBalanceSpan) {
                    tokenBalanceSpan.textContent = "500,000";
                }
                availableSpins = 5;
                if (availableSpinsSpan) availableSpinsSpan.textContent = availableSpins;
            }
        }

        // Use a spin (call API to decrement)
        async function useSpin() {
            if (!isWalletConnected) return false;

            try {
                const response = await fetch(`${API_BASE}/api/spins/use`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    console.warn("⚠️ Failed to use spin:", error.error);
                    return false;
                }

                const result = await response.json();
                availableSpins = result.availableSpins;
                if (availableSpinsSpan) availableSpinsSpan.textContent = availableSpins;
                
                console.log("✅ Spin used, remaining:", availableSpins);
                return true;
            } catch (error) {
                console.error("❌ Error using spin:", error);
                return false;
            }
        }

        // Record winnings (call API to add to total earnings)
        async function recordWinnings(solAmount) {
            if (!isWalletConnected || !solAmount || solAmount <= 0) return;

            try {
                const response = await fetch(`${API_BASE}/api/spins/win`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ solAmount })
                });

                if (!response.ok) {
                    console.warn("⚠️ Failed to record winnings");
                    return;
                }

                const result = await response.json();
                
                // Update total earnings display
                const totalEarningsSpan = document.getElementById('total-earnings');
                if (totalEarningsSpan) {
                    totalEarningsSpan.textContent = result.totalEarnings.toFixed(6);
                }
                
                console.log(`💰 Recorded +${solAmount} SOL, total: ${result.totalEarnings.toFixed(6)}`);
            } catch (error) {
                console.error("❌ Error recording winnings:", error);
            }
        }

        // Disconnect wallet and clear session
        async function disconnectWallet() {
            try {
                await fetch(`${API_BASE}/api/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });
            } catch (error) {
                console.warn("⚠️ Logout API call failed:", error);
            }
            
            // Clear local state
            userPublicKey = null;
            isWalletConnected = false;
            availableSpins = 0;
            
            // Stop refresh timer
            if (refreshTimerInterval) {
                clearInterval(refreshTimerInterval);
                refreshTimerInterval = null;
            }
            
            // Reset UI
            if (walletInfo) walletInfo.style.display = "none";
            if (connectWalletBtn) {
                connectWalletBtn.innerHTML = '<span class="wallet-icon">👻</span><span class="wallet-text">Authenticate Wallet</span>';
                connectWalletBtn.disabled = false;
            }
            if (availableSpinsSpan) availableSpinsSpan.textContent = "0";
            if (walletAddressSpan) walletAddressSpan.textContent = "";
            
            // Clear additional UI elements
            const totalEarningsSpan = document.getElementById('total-earnings');
            if (totalEarningsSpan) totalEarningsSpan.textContent = "0";
            
            const refreshTimerSpan = document.getElementById('refresh-timer');
            if (refreshTimerSpan) refreshTimerSpan.textContent = "--";
            
            console.log("👋 Wallet disconnected");
        }

        // ──────────────────────────────────────────────────────────────────────────
        // INTEGRATION WITH EXISTING SLOT MACHINE
        // ──────────────────────────────────────────────────────────────────────────

        // Override the existing spin function to check for available spins
        const originalSpinOnce = window.spinOnce;
        
        // Enhanced spin function that integrates with new spin system
        window.spinOnce = async function(options = {}) {
            // Only check spins for manual spins, not auto-spin sub-spins
            const isAutoSpin = options && options.skipBuildup;
            
            // If wallet is connected, use the API-based spin system
            if (isWalletConnected) {
                // For all spins (manual and auto), check available spins and consume one
                if (availableSpins <= 0) {
                    showNoSpinsNotification();
                    return;
                }
                
                // Use the API to consume one spin
                const spinUsed = await useSpin();
                if (!spinUsed) {
                    showNotification(
                        'Spin Failed!',
                        'Unable to use spin. Please check your connection and try again.',
                        '❌',
                        'warning'
                    );
                    return;
                }
            }

            // Call the original spin function and capture result
            let result = null;
            if (originalSpinOnce) {
                result = await originalSpinOnce.call(this, options);
            }

            return result;
        };

        // Hook into the win tracking system to record earnings
        const originalPayOutToPlayer = window.payOutToPlayer;
        if (originalPayOutToPlayer) {
            window.payOutToPlayer = function(solAmount) {
                // Call original function
                const result = originalPayOutToPlayer.call(this, solAmount);
                
                // Record winnings in our system if wallet is connected
                if (isWalletConnected && solAmount > 0) {
                    recordWinnings(solAmount);
                }
                
                return result;
            };
        }

        // Wins are now recorded directly in the horizontal tumble system
        // The payOutToPlayer function handles all win tracking automatically

        // ──────────────────────────────────────────────────────────────────────────
        // INITIALIZATION
        // ──────────────────────────────────────────────────────────────────────────

        // Event listeners with safe element access
        if (connectWalletBtn) {
            connectWalletBtn.addEventListener('click', connectWallet);
        } else {
            console.warn("⚠️ [Crypto] Connect wallet button not found - wallet connection disabled");
        }

        // Disconnect wallet button event listener
        const disconnectWalletBtn = document.getElementById('disconnect-wallet-btn');
        if (disconnectWalletBtn) {
            disconnectWalletBtn.addEventListener('click', async () => {
                // Show confirmation feedback
                disconnectWalletBtn.innerHTML = '<span class="wallet-icon">⏳</span><span class="wallet-text">Disconnecting...</span>';
                disconnectWalletBtn.disabled = true;
                
                await disconnectWallet();
                
                // Reset button state (though it should be hidden by now)
                disconnectWalletBtn.innerHTML = '<span class="wallet-icon">🚪</span><span class="wallet-text">Disconnect</span>';
                disconnectWalletBtn.disabled = false;
            });
        }

        // Check for existing session on page load
        async function checkExistingSession() {
            try {
                console.log("🔍 Checking for existing session...");
                
                // First check if we have a server session
                const statusResponse = await fetch(`${API_BASE}/api/status`, {
                    credentials: 'include'
                });
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    
                                            if (statusData.authenticated) {
                            // Check if Phantom is available and matches the stored session
                            try {
                                if (provider && provider.isPhantom) {
                                    // Try to silently reconnect if the user has already authorized this site
                                    try {
                                        await provider.connect({ onlyIfTrusted: true });
                                        console.log("✅ Silent reconnection successful");
                                    } catch (silentError) {
                                        console.log("💡 Silent reconnection failed, user will need to reconnect manually");
                                        // Don't throw here - just clear the session and let user reconnect
                                        await disconnectWallet();
                                        return false;
                                    }
                                    
                                    // Restore session state
                                    userPublicKey = statusData.publicKey;
                                    isWalletConnected = true;
                                    updateWalletUI();
                                    await updateTokenBalance();
                                    
                                    // Start refresh timer
                                    startRefreshTimer();
                                    
                                    console.log("✅ Session restored for:", userPublicKey);
                                    showNotification(
                                        'Welcome Back!',
                                        'Your wallet session has been restored. Ready to play!',
                                        '👋',
                                        'success'
                                    );
                                    return true;
                                } else {
                                    console.log("💡 Phantom wallet not available, clearing session");
                                    await disconnectWallet();
                                }
                            } catch (walletError) {
                                console.log("💡 Error checking wallet availability, clearing session");
                                await disconnectWallet();
                            }
                        }
                }
                
                console.log("💡 No active session found");
                return false;
                
            } catch (error) {
                console.warn("⚠️ Session check failed:", error);
                return false;
            }
        }

        // Setup refresh timer updates
        function startRefreshTimer() {
            if (refreshTimerInterval) {
                clearInterval(refreshTimerInterval);
            }
            
            refreshTimerInterval = setInterval(async () => {
                if (isWalletConnected) {
                    await updateTokenBalance();
                }
            }, 60000); // Update every minute
        }

        let refreshTimerInterval = null;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("🚀 Initializing Crypto Casino Integration...");
            
            await getTokenConfig();
            setupLiveWinsListener();
            
            // Check for existing session instead of auto-connecting wallet
            const sessionRestored = await checkExistingSession();
            
            // Start refresh timer if wallet is connected
            if (sessionRestored) {
                startRefreshTimer();
            }
            
            // Initialize payout request functionality
            initializePayoutRequest();
            
            console.log("✅ Crypto Casino Integration Complete!");
        });

        // ──────────────────────────────────────────────────────────────────────────
        // PAYOUT REQUEST FUNCTIONALITY
        // ──────────────────────────────────────────────────────────────────────────

        function initializePayoutRequest() {
            const payoutForm = document.getElementById('payout-form');
            const payoutAmount = document.getElementById('payout-amount');
            const payoutStatus = document.getElementById('payout-status');

            if (!payoutForm || !payoutAmount || !payoutStatus) {
                console.warn("⚠️ Payout request elements not found");
                return;
            }

            payoutForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const amount = parseFloat(payoutAmount.value);
                
                // Validation
                if (!isWalletConnected) {
                    showPayoutStatus('Please connect your wallet first', 'error');
                    return;
                }
                
                if (!amount || amount <= 0) {
                    showPayoutStatus('Please enter a valid amount', 'error');
                    return;
                }
                
                if (amount < 0.001) {
                    showPayoutStatus('Minimum payout is 0.001 SOL', 'error');
                    return;
                }
                
                // Check if user has enough winnings (this would need to track actual winnings)
                const currentWinnings = runningSolTotal || 0;
                if (amount > currentWinnings) {
                    showPayoutStatus(`Insufficient winnings. You have ${currentWinnings.toFixed(6)} SOL`, 'error');
                    return;
                }
                
                // Process payout request
                await processPayoutRequest(amount);
            });
        }

        function showPayoutStatus(message, type = 'pending') {
            const payoutStatus = document.getElementById('payout-status');
            if (!payoutStatus) return;
            
            payoutStatus.textContent = message;
            payoutStatus.className = type;
            
            // Auto-clear after 5 seconds
            setTimeout(() => {
                payoutStatus.textContent = '';
                payoutStatus.className = '';
            }, 5000);
        }

        async function processPayoutRequest(amount) {
            try {
                showPayoutStatus('Processing payout request...', 'pending');
                const wallet = userPublicKey;
                console.log('📤 Submitting payout request:', { wallet, amount });
                // Save request to Firestore
                let ref = null;
                if (db && wallet) {
                    ref = await db.collection("payoutRequests").add({
                        wallet: wallet,
                        amount: amount,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        fulfilled: false
                    });
                    console.log('✅ Payout request saved with ID:', ref.id);
                }
                // Deduct from running totals
                runningSolTotal = Math.max(0, runningSolTotal - amount);
                runningUsdTotal = Math.max(0, runningUsdTotal - (amount * (currentSolPriceUsd || 150)));
                $('#counter-sol').text(runningSolTotal.toFixed(6));
                $('#counter-usd').text(runningUsdTotal.toFixed(2));
                document.getElementById('payout-amount').value = '';
                showPayoutStatus(`✅ Payout request submitted: ${amount} SOL`, 'success');
                showNotification('Payout Requested!', `Your request for ${amount} SOL has been submitted and will be processed within 24 hours.`, '💰', 'success');
            } catch (error) {
                console.error('❌ Error submitting payout request:', error);
                showPayoutStatus('Payout request failed. Please try again.', 'error');
            }
        }

        // ──────────────────────────────────────────────────────────────────────────
        // WELCOME BANNER FUNCTIONALITY
        // ──────────────────────────────────────────────────────────────────────────
        
        // Show welcome banner and handle close
        document.addEventListener('DOMContentLoaded', function() {
            const welcomeBanner = document.getElementById('welcome-banner');
            const welcomeClose = document.getElementById('welcome-close');
            
            // Show banner if user hasn't seen it before
            if (!localStorage.getItem('welcome-banner-closed')) {
                setTimeout(() => {
                    if (welcomeBanner) welcomeBanner.style.display = 'block';
                }, 1000); // Show after 1 second
            }
            
            // Handle close button
            if (welcomeClose) {
                welcomeClose.addEventListener('click', () => {
                    if (welcomeBanner) {
                        welcomeBanner.style.display = 'none';
                        localStorage.setItem('welcome-banner-closed', 'true');
                    }
                });
            }
        });

    </script>

    <!-- ──────────────────────────────────────────────────────────────────────── -->
    <!-- WELCOME INFO BANNER -->
    <!-- ──────────────────────────────────────────────────────────────────────── -->
    <div id="welcome-banner" class="welcome-banner" style="display: none;">
        <div class="welcome-content">
            <div class="welcome-icon">🎰</div>
            <div class="welcome-text">
                <h2>Welcome to Meme Bonanza!</h2>
                <p>Meme Bonanza is a lottery website, based on the popular game Sweet Bonanza. The prizepool is funded by bonk creator rewards.</p>
            </div>
            <button id="welcome-close" class="welcome-close-btn">×</button>
        </div>
    </div>

    <!-- ──────────────────────────────────────────────────────────────────────── -->
    <!-- NOTIFICATION OVERLAY -->
    <!-- ──────────────────────────────────────────────────────────────────────── -->
    <div id="notification-overlay" class="notification-overlay">
        <div class="notification-box">
            <div class="notification-icon">🎰</div>
            <div class="notification-title" id="notification-title">Notification</div>
            <div class="notification-message" id="notification-message">Message goes here</div>
                        <div class="notification-buttons">
                <button id="notification-close" class="notification-btn">OK</button>
            </div>
        </div>
    </div>

    <!-- Add CSS for welcome banner and user-balance-panel -->
    <style>
        /* ─────────────── WELCOME BANNER STYLES ─────────────── */
        .welcome-banner {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            max-width: 600px;
            width: 90%;
            animation: slideDown 0.5s ease-out;
        }

        .welcome-content {
            background: linear-gradient(135deg, #ff3ebf 0%, #74b9ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .welcome-icon {
            font-size: 2.5rem;
            flex-shrink: 0;
        }

        .welcome-text {
            flex: 1;
            color: white;
        }

        .welcome-text h2 {
            margin: 0 0 8px 0;
            font-family: 'Press Start 2P', monospace;
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .welcome-text p {
            margin: 0;
            font-family: "Poppins", sans-serif;
            font-size: 0.95rem;
            line-height: 1.4;
            opacity: 0.95;
        }

        .welcome-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .welcome-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .welcome-banner {
                top: 10px;
                width: 95%;
            }
            
            .welcome-content {
                padding: 15px;
                gap: 10px;
            }
            
            .welcome-text h2 {
                font-size: 1rem;
            }
            
            .welcome-text p {
                font-size: 0.85rem;
            }
            
            .welcome-icon {
                font-size: 2rem;
            }
        }

        /* ─────────────── USER BALANCE PANEL ─────────────── */
        .user-balance-panel {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00e5ff;
            border-radius: 10px;
            padding: 16px;
            color: #e3e3e5;
            width: 200px;
            font-family: "Poppins", sans-serif;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
            margin-bottom: 16px;
        }
        .user-balance-panel h3 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
            color: #00e5ff;
            font-family: 'Press Start 2P', monospace;
            text-align: center;
        }
        #total-earned {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            color: #00ffab;
        }
    </style>

    <!-- Add HTML inside left-panels before payout-panel -->
    <div id="user-balance-panel" class="user-balance-panel">
        <h3>💰 Total Earned</h3>
        <p id="total-earned">0.000 SOL</p>
    </div>

    <!-- Additional user tracking script -->
    <script>
        let unsubscribeUserTotal = null;
        function subscribeToUserTotal(wallet){
            const earnedEl=document.getElementById('total-earned');
            if(!db||!wallet||!earnedEl) return;
            if(unsubscribeUserTotal) unsubscribeUserTotal();
            unsubscribeUserTotal = db.collection('userWinnings').doc(wallet)
                .onSnapshot(doc=>{
                    const total = doc.exists ? (doc.data().total||0) : 0;
                    earnedEl.textContent = total.toFixed(3)+' SOL';
                });
        }
    </script>
</body>
</html> 